/**
 * @typedef {import('chalk').ChalkInstance} 范_粉笔工具
 */

/**
 * @typedef {import('node:path')} 范_路径工具
 */

/**
 * @typedef {import('fs-extra')} 范_文件系统工具之扩展版
 */

/**
 * @typedef {import('../辅助工具集')} 范_本工具集随附之辅助工具集
 */

/**
 * @typedef {import('./0-常量表')} 范_本工具集之内部常量表
 */

/**
 * @typedef {import('../../../package.json')} 范_本工具集自身的_packageJSON
 */

/**
 * @typedef {import('../../../package.json')} 范_通用的_packageJSON # 这里假借本工具集自身的 package.json 来表征通用 package.json 的类型定义。因为真正的通用类型定义暂未找到，而假借的这一类型定义也够用了。
 */





/**
 * @param {object}                        配置项集
 *
 * @param {boolean}                       配置项集.应开启调试功能
 *
 * @param {范_粉笔工具}                   配置项集.粉笔工具
 * @param {范_路径工具}                   配置项集.路径工具
 * @param {范_文件系统工具之扩展版}       配置项集.文件系统工具之扩展版
 *
 * @param {范_本工具集随附之辅助工具集}   配置项集.本工具集随附之辅助工具集
 *
 * @param {string}                        配置项集.本工具集一切命令行消息之前缀
 * @param {string}                        配置项集.本工具集自身根文件夹之完整路径
 * @param {范_本工具集自身的_packageJSON} 配置项集.本工具集自身的_packageJSON
 *
 * @param {string}                        配置项集.视作须为其安装本工具集的_npm_项目的根文件的完整路径
 * @param {范_通用的_packageJSON}         配置项集.视作须为其安装本工具集的_npm_项目的_packageJSON
 * @param {string}                        配置项集.用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径
 * @param {string}                        配置项集.本工具集随附命令行应用范本集文件夹之相对路径
 * @param {string}                        配置项集.用于研发阶段的命令行工具集_这一文件夹之相对路径
 * @param {boolean}                       配置项集.发布本工具集随附的命令行脚本时_个别脚本文件应发布在目标项目之根文件夹下
 * @param {boolean}                       配置项集.发布本工具集随附的命令行脚本时应覆盖旧有的命令行脚本文件
 * @param {boolean}                       配置项集.发布本工具集随附的命令行脚本时若覆盖旧有的命令行脚本文件则先行备份
 *
 * @returns {Promise<any>}
 */
module.exports = function 将本工具集随附命令行应用范本文件发布至采用本工具集的_npm_包中去 ({
    应开启调试功能,

    粉笔工具,
    路径工具,
    文件系统工具之扩展版,

    本工具集随附之辅助工具集,

    本工具集一切命令行消息之前缀,
    本工具集自身根文件夹之完整路径,
    本工具集自身的_packageJSON,

    视作须为其安装本工具集的_npm_项目的根文件的完整路径,
    视作须为其安装本工具集的_npm_项目的_packageJSON,
    用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径,
    本工具集随附命令行应用范本集文件夹之相对路径,
    用于研发阶段的命令行工具集_这一文件夹之相对路径,
    发布本工具集随附的命令行脚本时_个别脚本文件应发布在目标项目之根文件夹下,
    发布本工具集随附的命令行脚本时应覆盖旧有的命令行脚本文件,
    发布本工具集随附的命令行脚本时若覆盖旧有的命令行脚本文件则先行备份,
} = {}) {
    应开启调试功能 && console.debug('>>>> 将本工具集随附命令行应用范本文件发布至采用本工具集的_npm_包中去 <<<<')

    if (typeof 视作须为其安装本工具集的_npm_项目的根文件的完整路径 !== 'string' || !视作须为其安装本工具集的_npm_项目的根文件的完整路径.trim()) {
        return Promise.reject(new Error(`${
            本工具集一切命令行消息之前缀
        }\n    ${
            粉笔工具.red(`没有给出【${
                粉笔工具.yellow('视作须为其安装本工具集的_npm_项目的根文件的完整路径')
            }】。`)
        }\n`))
    }

    return Promise.all([
        import('./0-常量表.js'),
    ]).then(([
        本工具集之内部常量表_模块,
    ]) => {
        应开启调试功能 && console.debug('>>>> 将本工具集随附命令行应用范本文件发布至采用本工具集的_npm_包中去 then <<<<')

        /** @type {范_本工具集之内部常量表} */
        const 本工具集之内部常量表 = 本工具集之内部常量表_模块.default

        发布命令行脚本之范本集_主体功能({
            应开启调试功能,

            粉笔工具,
            路径工具,
            文件系统工具之扩展版,

            本工具集随附之辅助工具集,
            本工具集之内部常量表,

            本工具集一切命令行消息之前缀,
            本工具集自身根文件夹之完整路径,
            本工具集自身的_packageJSON,

            视作须为其安装本工具集的_npm_项目的根文件的完整路径,
            视作须为其安装本工具集的_npm_项目的_packageJSON,
            用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径,
            本工具集随附命令行应用范本集文件夹之相对路径,
            用于研发阶段的命令行工具集_这一文件夹之相对路径,
            发布本工具集随附的命令行脚本时_个别脚本文件应发布在目标项目之根文件夹下,
            发布本工具集随附的命令行脚本时应覆盖旧有的命令行脚本文件,
            发布本工具集随附的命令行脚本时若覆盖旧有的命令行脚本文件则先行备份,
        })
    })
}





/**
 * @typedef {object} 范_命令行脚本文件之发布任务配置
 *
 * @property {boolean} 应尝试部署该文件
 * @property {boolean} 不论是否部署该文件也应尝试修订旧有文件
 * @property {string}  原始范本文件的二次相对路径
 * @property {string}  拟将范本文件发布于其中的文件夹的相对路径
 */





/**
 * @param {object}                        配置项集
 *
 * @param {boolean}                       配置项集.应开启调试功能
 *
 * @param {范_粉笔工具}                   配置项集.粉笔工具
 * @param {范_路径工具}                   配置项集.路径工具
 * @param {范_文件系统工具之扩展版}       配置项集.文件系统工具之扩展版
 *
 * @param {范_本工具集随附之辅助工具集}   配置项集.本工具集随附之辅助工具集
 * @param {范_本工具集之内部常量表}       配置项集.本工具集之内部常量表
 *
 * @param {string}                        配置项集.本工具集一切命令行消息之前缀
 * @param {string}                        配置项集.本工具集自身根文件夹之完整路径
 * @param {范_本工具集自身的_packageJSON} 配置项集.本工具集自身的_packageJSON
 *
 * @param {string}                        配置项集.视作须为其安装本工具集的_npm_项目的根文件的完整路径
 * @param {范_通用的_packageJSON}         配置项集.视作须为其安装本工具集的_npm_项目的_packageJSON
 * @param {string}                        配置项集.用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径
 * @param {string}                        配置项集.本工具集随附命令行应用范本集文件夹之相对路径      - 默认值为 '源代码/命令行应用范本集' 。
 * @param {string}                        配置项集.用于研发阶段的命令行工具集_这一文件夹之相对路径     - 默认值为 '用于研发阶段的命令行工具集' 。
 * @param {boolean}                       配置项集.发布本工具集随附的命令行脚本时_个别脚本文件应发布在目标项目之根文件夹下
 * @param {boolean}                       配置项集.发布本工具集随附的命令行脚本时应覆盖旧有的命令行脚本文件
 * @param {boolean}                       配置项集.发布本工具集随附的命令行脚本时若覆盖旧有的命令行脚本文件则先行备份
 */
function 发布命令行脚本之范本集_主体功能 ({
    应开启调试功能,

    粉笔工具,
    路径工具,
    文件系统工具之扩展版,

    本工具集随附之辅助工具集,
    本工具集之内部常量表,

    本工具集一切命令行消息之前缀,
    本工具集自身根文件夹之完整路径,
    本工具集自身的_packageJSON,

    视作须为其安装本工具集的_npm_项目的根文件的完整路径,
    视作须为其安装本工具集的_npm_项目的_packageJSON,
    用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径,
    本工具集随附命令行应用范本集文件夹之相对路径,
    用于研发阶段的命令行工具集_这一文件夹之相对路径,
    // 发布本工具集随附的命令行脚本时_个别脚本文件应发布在目标项目之根文件夹下,
    发布本工具集随附的命令行脚本时应覆盖旧有的命令行脚本文件,
    发布本工具集随附的命令行脚本时若覆盖旧有的命令行脚本文件则先行备份,
}) {
    应开启调试功能 && console.debug('>>>> 发布命令行脚本之范本集_主体功能 <<<<')

    const {
        用于研发阶段的命令行工具集_这一文件夹之相对路径_默认值,
    } = 本工具集之内部常量表



    if (typeof 本工具集随附命令行应用范本集文件夹之相对路径 !== 'string' || !本工具集随附命令行应用范本集文件夹之相对路径.trim()) {
        本工具集随附命令行应用范本集文件夹之相对路径 = '源代码/命令行应用范本集'
    }

    if (typeof 用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径 !== 'string' || !用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径.trim()) {
        用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径 = 视作须为其安装本工具集的_npm_项目的根文件的完整路径
    }

    /** @type {string} */
    let 用于研发阶段的命令行工具集_这一文件夹之相对路径_采纳值
    if (typeof 用于研发阶段的命令行工具集_这一文件夹之相对路径 !== 'string' || !用于研发阶段的命令行工具集_这一文件夹之相对路径.trim()) {
        用于研发阶段的命令行工具集_这一文件夹之相对路径_采纳值 = 用于研发阶段的命令行工具集_这一文件夹之相对路径_默认值
    } else {
        用于研发阶段的命令行工具集_这一文件夹之相对路径_采纳值 = 用于研发阶段的命令行工具集_这一文件夹之相对路径
    }

    console.info(`\n\n\n\n\n${
        本工具集一切命令行消息之前缀
    } ${
        粉笔工具.bgGreenBright.black(' 现在开始发布各命令行脚本 ')
    } 。\n`)

    console.log(`\n${
        本工具集一切命令行消息之前缀
    }\n\n    视作须为其安装本工具集的_npm_项目的根文件的完整路径：\n    "${
        粉笔工具.green(视作须为其安装本工具集的_npm_项目的根文件的完整路径)
    }"\n\n    用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径：\n    "${
        粉笔工具.green(用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径)
    }"\n`)

    // console.info(
    //     '    个别脚本文件应发布在目标项目之根文件夹下：\n   ',
    //     发布本工具集随附的命令行脚本时_个别脚本文件应发布在目标项目之根文件夹下,
    //     '\n'
    // )



    /** @type {Array<范_命令行脚本文件之发布任务配置>} */
    const 所有命令行脚本文件之发布任务配置集 = [
        {
            应尝试部署该文件:                         true,
            不论是否部署该文件也应尝试修订旧有文件:   true,
            原始范本文件的二次相对路径:               路径工具.join('PowerShell', 'Update-更新所有-npm-依赖包至允许范围内的最新版本.ps1'),
            拟将范本文件发布于其中的文件夹的相对路径: 路径工具.join(用于研发阶段的命令行工具集_这一文件夹之相对路径_采纳值, 'PowerShell'),
        },

        {
            应尝试部署该文件:                         true,
            不论是否部署该文件也应尝试修订旧有文件:   true,
            原始范本文件的二次相对路径:               路径工具.join('bash', 'update-更新所有-npm-依赖包至允许范围内的最新版本.sh'),
            拟将范本文件发布于其中的文件夹的相对路径: 路径工具.join(用于研发阶段的命令行工具集_这一文件夹之相对路径_采纳值, 'bash'),
        },
    ].filter(任务 => !!任务)



    // 为了日志清晰、有序、易读，我最终还是舍弃了 Promsie.all 或 Promsie.allSettled 的做法，改为顺次执行各功能。
    所有命令行脚本文件之发布任务配置集.forEach(某命令行脚本文件之发布任务配置 => {
        try {
            发布某脚本文件({
                应开启调试功能,

                粉笔工具,
                路径工具,
                文件系统工具之扩展版,

                本工具集随附之辅助工具集,
                本工具集之内部常量表,

                本工具集一切命令行消息之前缀,
                本工具集自身根文件夹之完整路径,
                本工具集自身的_packageJSON,

                本工具集随附命令行应用范本集文件夹之相对路径,
                用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径,
                用于研发阶段的命令行工具集_这一文件夹之相对路径: 用于研发阶段的命令行工具集_这一文件夹之相对路径_采纳值,
                发布本工具集随附的命令行脚本时应覆盖旧有的命令行脚本文件,
                发布本工具集随附的命令行脚本时若覆盖旧有的命令行脚本文件则先行备份,

                某命令行脚本文件之发布任务配置,

                视作须为其安装本工具集的_npm_项目的_packageJSON,
            })
        } catch (异常之记载) {
            console.error(`\n\n${
                本工具集一切命令行消息之前缀
            }\n${
                粉笔工具.bgRed.white(' 遭遇异常 ')
            }：\n${
                粉笔工具.red(异常之记载)
            }\n\n`)

            console.error(异常之记载)
        }
    })





    /**
     * @param {object}                          配置项集
     *
     * @param {boolean}                         配置项集.应开启调试功能
     *
     * @param {范_粉笔工具}                     配置项集.粉笔工具
     * @param {范_路径工具}                     配置项集.路径工具
     * @param {范_文件系统工具之扩展版}         配置项集.文件系统工具之扩展版
     *
     * @param {范_本工具集随附之辅助工具集}     配置项集.本工具集随附之辅助工具集
     * @param {范_本工具集之内部常量表}         配置项集.本工具集之内部常量表
     *
     * @param {string}                          配置项集.本工具集一切命令行消息之前缀
     * @param {string}                          配置项集.本工具集自身根文件夹之完整路径
     * @param {范_本工具集自身的_packageJSON}   配置项集.本工具集自身的_packageJSON
     *
     * @param {string}                          配置项集.本工具集随附命令行应用范本集文件夹之相对路径
     * @param {string}                          配置项集.用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径
     * @param {string}                          配置项集.用于研发阶段的命令行工具集_这一文件夹之相对路径
     * @param {boolean}                         配置项集.发布本工具集随附的命令行脚本时应覆盖旧有的命令行脚本文件
     * @param {boolean}                         配置项集.发布本工具集随附的命令行脚本时若覆盖旧有的命令行脚本文件则先行备份
     *
     * @param {范_命令行脚本文件之发布任务配置} 配置项集.某命令行脚本文件之发布任务配置
     *
     * @param {范_通用的_packageJSON}           配置项集.视作须为其安装本工具集的_npm_项目的_packageJSON
     */
    function 发布某脚本文件 ({
        应开启调试功能,

        粉笔工具,
        路径工具,
        文件系统工具之扩展版,

        本工具集随附之辅助工具集,
        本工具集之内部常量表,

        本工具集一切命令行消息之前缀,
        本工具集自身根文件夹之完整路径,
        本工具集自身的_packageJSON,

        本工具集随附命令行应用范本集文件夹之相对路径,
        用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径,
        用于研发阶段的命令行工具集_这一文件夹之相对路径,
        发布本工具集随附的命令行脚本时应覆盖旧有的命令行脚本文件,
        发布本工具集随附的命令行脚本时若覆盖旧有的命令行脚本文件则先行备份,

        某命令行脚本文件之发布任务配置,

        视作须为其安装本工具集的_npm_项目的_packageJSON,
    } = {}) {
        const 拼接路径片段 = 路径工具.join
        const 求完整路径 = 路径工具.resolve
        const 求路径中的文件之文件全名 = 路径工具.basename
        const 求路径末端实体的容纳文件夹之路径 = 路径工具.dirname



        const {
            用于研发阶段的命令行工具集_这一文件夹之相对路径_默认值,
            在_PowerShell_命令行范本中需替换为当前_npm_的_产品级_依赖包列表的插入引导文本,
            在_PowerShell_命令行范本中需替换为当前_npm_的_研发级_依赖包列表的插入引导文本,
            在_Bash_命令行范本中需替换为当前_npm_的_依赖包列表的插入引导文本_起始记号,
            在_Bash_命令行范本中需替换为当前_npm_的_依赖包列表的插入引导文本_结束记号,
            在_Bash_命令行中用作关键配置中的分割符的文本记号,
        } = 本工具集之内部常量表



        const {
            应尝试部署该文件,
            不论是否部署该文件也应尝试修订旧有文件,
            原始范本文件的二次相对路径,
            拟将范本文件发布于其中的文件夹的相对路径,
        } = 某命令行脚本文件之发布任务配置

        if (!应尝试部署该文件 && !不论是否部署该文件也应尝试修订旧有文件) {
            return
        }



        const 命令行脚本文件之文件名 = 求路径中的文件之文件全名(原始范本文件的二次相对路径)
        const 该命令行脚本文件确系PowerShell = /\.psm?1$/.test(命令行脚本文件之文件名)
        const 原始范本文件的一次相对路径 = 拼接路径片段(本工具集随附命令行应用范本集文件夹之相对路径, 原始范本文件的二次相对路径)
        const 容纳原始范本文件之文件夹之完整路径 = 求完整路径(求路径末端实体的容纳文件夹之路径(原始范本文件的一次相对路径))

        const 原始范本文件之完整路径 = 求完整路径(拼接路径片段(
            本工具集自身根文件夹之完整路径,
            本工具集随附命令行应用范本集文件夹之相对路径,
            原始范本文件的二次相对路径
        ))

        const 容纳发布的文件的文件夹之完整路径 = 求完整路径(拼接路径片段(
            用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径,
            拟将范本文件发布于其中的文件夹的相对路径
        ))

        const 拟发布成为之文件之完整路径 = 拼接路径片段(
            容纳发布的文件的文件夹之完整路径,
            命令行脚本文件之文件名
        )



        let 范文确实存在 = false
        if (文件系统工具之扩展版.existsSync(原始范本文件之完整路径)) {
            const 文件描述符 = 文件系统工具之扩展版.statSync(原始范本文件之完整路径)
            if (文件描述符.isFile()) {
                范文确实存在 = true
            }
        }



        let 欲发布的文件业已存在 = false
        if (文件系统工具之扩展版.existsSync(拟发布成为之文件之完整路径)) {
            const 文件描述符 = 文件系统工具之扩展版.statSync(拟发布成为之文件之完整路径)
            if (文件描述符.isFile()) {
                欲发布的文件业已存在 = true
            }
        }



        let 确应发布或覆盖该文件 = false
        let 确应保存备份文件 = false

        if (应尝试部署该文件) {

            if (!范文确实存在) {
                console.error(`${
                    本工具集一切命令行消息之前缀
                }\n${
                    粉笔工具.red('欲部署某命令行脚本工具时，未找到原始文件。已略过该部署任务。')
                }\n所涉文件之描述如下：\n    相对路径： "${
                    粉笔工具.redBright(原始范本文件的二次相对路径)
                }"\n    完整路径： "${
                    粉笔工具.redBright(原始范本文件之完整路径)
                }"\n`)

                return
            }



            console[欲发布的文件业已存在 ? 'warn' : 'log'](`${
                本工具集一切命令行消息之前缀
            }\n\n    找到原始的命令行脚本${粉笔工具.cyanBright('范本')}：\n    "${
                粉笔工具.white(`${容纳原始范本文件之文件夹之完整路径}${路径工具.sep}`)
            }${
                粉笔工具.cyan(命令行脚本文件之文件名)
            }"\n`)

            console[欲发布的文件业已存在 ? 'warn' : 'log'](`    ${
                粉笔工具.yellow('拟发布为：')
            }：\n    "${
                粉笔工具.green(`${容纳发布的文件的文件夹之完整路径}${路径工具.sep}`)
            }${
                粉笔工具.greenBright(命令行脚本文件之文件名)
            }"\n`)




            if (欲发布的文件业已存在) {
                console.warn(`   ${
                    粉笔工具.bgYellow.black(' 欲发布的命令行脚本文件业已存在 ')
                } 。`)
                // console.warn(`    ${
                //     粉笔工具.yellow('欲发布的命令行脚本文件业已存在')
                // }：\n    "${
                //     粉笔工具.blue(`${容纳发布的文件的文件夹之完整路径}${路径工具.sep}`)
                // }${
                //     粉笔工具.blueBright(命令行脚本文件之文件名)
                // }"\n`)

                if (发布本工具集随附的命令行脚本时应覆盖旧有的命令行脚本文件) {
                    确应发布或覆盖该文件 = true
                    确应保存备份文件 = !!发布本工具集随附的命令行脚本时若覆盖旧有的命令行脚本文件则先行备份

                    if (确应保存备份文件) {
                        console.warn(`   ${粉笔工具.bgMagenta.black(' 该文件将被覆盖，但会先行备份 ')} 。`)
                    } else {
                        console.warn(`   ${粉笔工具.bgRed.whiteBright(' 该文件将被覆盖，且不会先行备份 ')} 。`)
                    }
                } else {
                    确应发布或覆盖该文件 = false
                    确应保存备份文件 = false

                    console.warn(`   ${粉笔工具.bgGreen.black(' 不会发布新文件，而是保留旧有文件 ')} 。\n`)
                }
            } else {
                确应发布或覆盖该文件 = true
                确应保存备份文件 = false
            }

        }





        /**
         * @typedef {object} 范_向范文内容中插入各依赖包相关信息时的简易配置列表
         *
         * @property {'产品级' | '研发级' | '所有'} 待处理的依赖包之种类
         * @property {string} 在范文中引导插入或替换内容的标记文字_起始记号
         * @property {string} 在范文中引导插入或替换内容的标记文字_结束记号
         */



        /** @type {Array<范_向范文内容中插入各依赖包相关信息时的简易配置列表>} */
        const 向范文内容中插入各依赖包相关信息时的简易配置列表_PowerShell = [
            {
                待处理的依赖包之种类: '产品级',
                在范文中引导插入或替换内容的标记文字_起始记号: 在_PowerShell_命令行范本中需替换为当前_npm_的_产品级_依赖包列表的插入引导文本,
                在范文中引导插入或替换内容的标记文字_结束记号: null,
            },
            {
                待处理的依赖包之种类: '研发级',
                在范文中引导插入或替换内容的标记文字_起始记号: 在_PowerShell_命令行范本中需替换为当前_npm_的_研发级_依赖包列表的插入引导文本,
                在范文中引导插入或替换内容的标记文字_结束记号: null,
            },
        ]



        /** @type {Array<范_向范文内容中插入各依赖包相关信息时的简易配置列表>} */
        const 向范文内容中插入各依赖包相关信息时的简易配置列表_Bash = [
            {
                待处理的依赖包之种类: '所有',
                在范文中引导插入或替换内容的标记文字_起始记号: 在_Bash_命令行范本中需替换为当前_npm_的_依赖包列表的插入引导文本_起始记号,
                在范文中引导插入或替换内容的标记文字_结束记号: 在_Bash_命令行范本中需替换为当前_npm_的_依赖包列表的插入引导文本_结束记号,
            },
        ]


        /** @type {Array<范_向范文内容中插入各依赖包相关信息时的简易配置列表>} */
        let 向范文内容中插入各依赖包相关信息时的简易配置列表 = []





        if (确应发布或覆盖该文件) {

            文件系统工具之扩展版.mkdirpSync(容纳发布的文件的文件夹之完整路径)



            if (确应保存备份文件) {
                const 该命令行脚本文件之扩展名 = 路径工具.extname(命令行脚本文件之文件名)
                const 时间戳 = 本工具集随附之辅助工具集.求当前时间之文本_可用于文件系统之文件名()

                const 备份文件之文件名 = `${
                    路径工具.basename(命令行脚本文件之文件名, 该命令行脚本文件之扩展名)
                }-吴乐川备份于-${时间戳}${
                    该命令行脚本文件之扩展名
                }`

                const 备份文件之完整路径 = 拼接路径片段(
                    容纳发布的文件的文件夹之完整路径,
                    备份文件之文件名
                )

                文件系统工具之扩展版.copySync(拟发布成为之文件之完整路径, 备份文件之完整路径)
                console.warn(`   ${粉笔工具.bgGreen.black(' 旧文件现已备份 ')} 。`)
            }



            const 原始范文的内容须先修订再发布 = true // 用于研发阶段的命令行工具集_这一文件夹之相对路径 !== 用于研发阶段的命令行工具集_这一文件夹之相对路径_默认值

            if (!原始范文的内容须先修订再发布) {
                文件系统工具之扩展版.copySync(原始范本文件之完整路径, 拟发布成为之文件之完整路径)
                console.log(`   ${粉笔工具.bgBlueBright.black(' 该文件现已发布 ')} 。\n\n`)
            } else {
                const 原始范本文件之内容全文 = 文件系统工具之扩展版.readFileSync(原始范本文件之完整路径).toString()

                let 原始范本文件之内容全文之逐行内容列表 = 原始范本文件之内容全文.split(/\n/)



                if (该命令行脚本文件确系PowerShell) {
                    向范文内容中插入各依赖包相关信息时的简易配置列表 = 向范文内容中插入各依赖包相关信息时的简易配置列表_PowerShell
                } else {
                    向范文内容中插入各依赖包相关信息时的简易配置列表 = 向范文内容中插入各依赖包相关信息时的简易配置列表_Bash
                }



                向范文内容中插入各依赖包相关信息时的简易配置列表.forEach(({
                    待处理的依赖包之种类,
                    在范文中引导插入或替换内容的标记文字_起始记号,
                    在范文中引导插入或替换内容的标记文字_结束记号,
                }) => {
                    原始范本文件之内容全文之逐行内容列表 = 查找范文中的某标记并将真实的依赖包版本配置插入其后({
                        应开启调试功能,

                        粉笔工具,

                        本工具集一切命令行消息之前缀,
                        本工具集自身的_packageJSON,

                        修订前的文件内容全文之逐行内容列表: 原始范本文件之内容全文之逐行内容列表,
                        在范文中引导插入或替换内容的标记文字_起始记号,
                        在范文中引导插入或替换内容的标记文字_结束记号,
                        产出的内容确系用于PowerShell代码: 该命令行脚本文件确系PowerShell,

                        其依赖包配置待处理的_packageJSON: 视作须为其安装本工具集的_npm_项目的_packageJSON,
                        待处理的依赖包之种类,

                        在_Bash_命令行中用作关键配置中的分割符的文本记号,
                    })
                })

                let 修订后的范文内容全文 = 原始范本文件之内容全文之逐行内容列表.join('\n')



                修订后的范文内容全文 = 之于某命令行脚本文件之内容全文_修订其中提及的_用于研发阶段的命令行工具集({
                    文件内容修订前之全文: 修订后的范文内容全文,
                    该命令行脚本文件确系PowerShell,
                    用于研发阶段的命令行工具集_这一文件夹之相对路径_采纳值: 用于研发阶段的命令行工具集_这一文件夹之相对路径,
                    用于研发阶段的命令行工具集_这一文件夹之相对路径_默认值,
                })

                文件系统工具之扩展版.writeFileSync(拟发布成为之文件之完整路径, 修订后的范文内容全文)
                console[欲发布的文件业已存在 ? 'warn' : 'log'](`   ${粉笔工具.bgBlueBright.black(' 该文件现已发布 ')} 。\n\n`)
            }

        } else { // 这是 if (确应发布该文件) 配对的 else 。

            if (!欲发布的文件业已存在) {
                return
            }





            console.info(`${
                本工具集一切命令行消息之前缀
            }\n\n    找到${粉笔工具.yellow('旧有的')}命令行脚本：\n    "${
                粉笔工具.green(`${容纳发布的文件的文件夹之完整路径}${路径工具.sep}`)
            }${
                粉笔工具.greenBright(命令行脚本文件之文件名)
            }"\n`)



            const 旧有命令行脚本文件之原始内容全文 = 文件系统工具之扩展版.readFileSync(拟发布成为之文件之完整路径).toString()



            const 该文件值得修订 = true // 横竖是要修订“用于研发阶段的命令行工具集” 这一配置的。再做如此检查则太麻烦。



            let 修订好的命令行脚本文件内容全文  = 之于某命令行脚本文件之内容全文_修订其中提及的_用于研发阶段的命令行工具集({
                文件内容修订前之全文: 旧有命令行脚本文件之原始内容全文,
                该命令行脚本文件确系PowerShell,
                用于研发阶段的命令行工具集_这一文件夹之相对路径_采纳值: 用于研发阶段的命令行工具集_这一文件夹之相对路径,
                用于研发阶段的命令行工具集_这一文件夹之相对路径_默认值,
            })



            if (该命令行脚本文件确系PowerShell) {
                const 正则表达式1 = /\\@wulechuan\\cli-scripts--npm-project-helpers\\源代码\\PowerShell/

                // 该文件值得修订 = 正则表达式1.test(修订好的命令行脚本文件内容全文) // 横竖是要另外修订“用于研发阶段的命令行工具集” 这一配置的。

                修订好的命令行脚本文件内容全文 = 修订好的命令行脚本文件内容全文.replace(
                    正则表达式1,
                    '\\@wulechuan\\cli-scripts--npm-project-helpers\\源代码\\发布的源代码\\PowerShell'
                )
            } else {
                const 正则表达式1 = /\/@wulechuan\/cli-scripts--npm-project-helpers\/源代码\/bash/

                // 该文件值得修订 = 正则表达式1.test(修订好的命令行脚本文件内容全文) // 横竖是要另外修订“用于研发阶段的命令行工具集” 这一配置的。

                修订好的命令行脚本文件内容全文 = 修订好的命令行脚本文件内容全文.replace(
                    正则表达式1,
                    '/@wulechuan/cli-scripts--npm-project-helpers/源代码/发布的源代码/bash'
                )
            }



            let 修订中的范本文件之内容全文之逐行内容列表 = 修订好的命令行脚本文件内容全文.split(/\n/)

            if (该命令行脚本文件确系PowerShell) {
                向范文内容中插入各依赖包相关信息时的简易配置列表 = []
            } else {
                向范文内容中插入各依赖包相关信息时的简易配置列表 = 向范文内容中插入各依赖包相关信息时的简易配置列表_Bash
            }



            向范文内容中插入各依赖包相关信息时的简易配置列表.forEach(({
                待处理的依赖包之种类,
                在范文中引导插入或替换内容的标记文字_起始记号,
                在范文中引导插入或替换内容的标记文字_结束记号,
            }) => {
                修订中的范本文件之内容全文之逐行内容列表 = 查找范文中的某标记并将真实的依赖包版本配置插入其后({
                    应开启调试功能,

                    粉笔工具,

                    本工具集一切命令行消息之前缀,
                    本工具集自身的_packageJSON,

                    修订前的文件内容全文之逐行内容列表: 修订中的范本文件之内容全文之逐行内容列表,
                    在范文中引导插入或替换内容的标记文字_起始记号,
                    在范文中引导插入或替换内容的标记文字_结束记号,
                    产出的内容确系用于PowerShell代码: 该命令行脚本文件确系PowerShell,

                    其依赖包配置待处理的_packageJSON: 视作须为其安装本工具集的_npm_项目的_packageJSON,
                    待处理的依赖包之种类,

                    在_Bash_命令行中用作关键配置中的分割符的文本记号,
                })
            })

            修订好的命令行脚本文件内容全文 = 修订中的范本文件之内容全文之逐行内容列表.join('\n')



            if (该文件值得修订 && 修订好的命令行脚本文件内容全文) {
                文件系统工具之扩展版.writeFileSync(拟发布成为之文件之完整路径, 修订好的命令行脚本文件内容全文)



                console.info(`   ${粉笔工具.bgBlueBright.black(' 该旧有文件现已修订 ')} 。\n\n`)
            }
        }
    }




    /**
     * @param {object}  配置项集
     * @param {string}  配置项集.文件内容修订前之全文
     * @param {string}  配置项集.用于研发阶段的命令行工具集_这一文件夹之相对路径
     * @param {string}  配置项集.用于研发阶段的命令行工具集_这一文件夹之相对路径_默认值
     * @param {boolean} 配置项集.该命令行脚本文件确系PowerShell
     *
     * @returns {string}
     */
    function 之于某命令行脚本文件之内容全文_修订其中提及的_用于研发阶段的命令行工具集 ({
        文件内容修订前之全文,
        该命令行脚本文件确系PowerShell,
        用于研发阶段的命令行工具集_这一文件夹之相对路径_采纳值,
        用于研发阶段的命令行工具集_这一文件夹之相对路径_默认值,
    } = {}) {

        // console.debug(用于研发阶段的命令行工具集_这一文件夹之相对路径_采纳值.split(/[\\/]/))
        const 用于研发阶段的命令行工具集_这一文件夹之相对路径各级有效片段之列表 = 用于研发阶段的命令行工具集_这一文件夹之相对路径_采纳值.split(/[\\/]/).filter(片段 => !!片段)
        const 用于研发阶段的命令行工具集_这一文件夹之相对路径包含的路径层级数 = 用于研发阶段的命令行工具集_这一文件夹之相对路径各级有效片段之列表.length

        /**
         * 目前的真实情况是， “用于研发阶段的命令行工具集” 这一路径仅仅用于 PowerShell 脚本中的 -match 运算符后的【正则表达式】这一处。别无他处采用之。
         * 这时，即便文件是 PowerShell ，该正则表达式中的路径分隔符也必须为“双【反斜杠】”，而不是 PowerShell 风格的【代字符】 "`\" 。
         * 因此，暂时不必分过多情况讨论“应写入文件的各色路径中应采用的分隔符”的值。
         */
        let 写入文件的各色路径中应采用的分隔符 = 路径工具.sep === '\\' ? '\\\\' : 路径工具.sep
        if (!该命令行脚本文件确系PowerShell) {
            写入文件的各色路径中应采用的分隔符 = '/'
        }

        // /** @type {string} */
        // let 写入文件的各色路径中应采用的分隔符
        // if (该命令行脚本文件确系PowerShell) {
        //     写入文件的各色路径中应采用的分隔符 = 路径工具.sep === '\\' ? '`\\' : 路径工具.sep
        // } else {
        //     写入文件的各色路径中应采用的分隔符 = 路径工具.sep === '\\' ? '\\\\' : '/'
        // }



        let 修订后的内容全文 = 文件内容修订前之全文.replace(
            new RegExp(
                用于研发阶段的命令行工具集_这一文件夹之相对路径_默认值
                    .replace(/[[\]]/g, '\\$1')           // 先处理路径片段中原有的方括号。
                    .replace(/[\\/]/g, '[\\\\/]')        // 在处理路径分隔符（即 \ 或 /），此时要添加额外的方括号。
                    .replace(/([{(.$!^+\-)}])/g, '\\$1') // 最后处理其他对于文件路径而言可以使用但对正则表达式而言很特殊的字符。
                ,

                'g'
            ),

            用于研发阶段的命令行工具集_这一文件夹之相对路径各级有效片段之列表.join(写入文件的各色路径中应采用的分隔符)
        )



        if (该命令行脚本文件确系PowerShell) {
            const 须替换成的文本片段 = `Set-Location ${
                new Array(用于研发阶段的命令行工具集_这一文件夹之相对路径包含的路径层级数 + 1).fill('..').join('\\')
            }${'\\'} # 确保进程的当前路径为接受本工具集服务的 npm 包的根文件夹。`

            // console.debug(
            //     /[Ss][Ee][Tt]-[Ll][Oo][Cc][Aa][Tt][Ii][Oo][Nn]\s+'\.\.\\\.\.\\'\s+#\s*确保进程的当前路径为接受本工具集服务的 npm 包的根文件夹。/.test(修订后的内容全文),
            //     须替换成的文本片段,
            //     '\n父级路径层数', 用于研发阶段的命令行工具集_这一文件夹之相对路径包含的路径层级数
            // )

            修订后的内容全文 = 修订后的内容全文.replace(
                /[Ss][Ee][Tt]-[Ll][Oo][Cc][Aa][Tt][Ii][Oo][Nn]\s+'\.\.\\\.\.\\'\s+#\s*确保进程的当前路径为接受本工具集服务的 npm 包的根文件夹。/,
                须替换成的文本片段
            )
        }



        return 修订后的内容全文
    }




    /**
     *
     * @param {object}                                 配置项集
     *
     * @param {boolean}                                配置项集.应开启调试功能
     *
     * @param {范_粉笔工具}                            配置项集.粉笔工具
     *
     * @param {string}                                 配置项集.本工具集一切命令行消息之前缀
     * @param {范_本工具集自身的_packageJSON}          配置项集.本工具集自身的_packageJSON
     *
     * @param {string[]}                               配置项集.修订前的文件内容全文之逐行内容列表
     * @param {string}                                 配置项集.在范文中引导插入或替换内容的标记文字_起始记号
     * @param {string}                                 配置项集.在范文中引导插入或替换内容的标记文字_结束记号
     * @param {boolean}                                配置项集.产出的内容确系用于PowerShell代码
     *
     * @param {范_通用的_packageJSON}                  配置项集.其依赖包配置待处理的_packageJSON
     * @param {'产品级' | '研发级' | '所有'}           配置项集.待处理的依赖包之种类
     * @param {string}                                 配置项集.在_Bash_命令行中用作关键配置中的分割符的文本记号
     *
     * @returns {string[]}
     */
    function 查找范文中的某标记并将真实的依赖包版本配置插入其后 ({
        应开启调试功能,

        粉笔工具,

        本工具集一切命令行消息之前缀,
        本工具集自身的_packageJSON,

        修订前的文件内容全文之逐行内容列表: 修订前的文件内容全文之逐行内容列表,
        在范文中引导插入或替换内容的标记文字_起始记号,
        在范文中引导插入或替换内容的标记文字_结束记号,
        产出的内容确系用于PowerShell代码,

        其依赖包配置待处理的_packageJSON,
        待处理的依赖包之种类,
        在_Bash_命令行中用作关键配置中的分割符的文本记号,
    } = {}) {
        const 本函数之一切消息之前缀 = `\n${本工具集一切命令行消息之前缀}\n函数： ${
            粉笔工具.magentaBright('查找范文中的某标记并将真实的依赖包版本配置插入其后')
        }\n`



        应开启调试功能 && console.debug(本函数之一切消息之前缀, `>>>> ${产出的内容确系用于PowerShell代码 ? 'PowerShell' : 'Bash' } - ${待处理的依赖包之种类} <<<<\n`)



        if (!Array.isArray(修订前的文件内容全文之逐行内容列表)) {
            应开启调试功能 && console.debug(`${
                本函数之一切消息之前缀
            }    参数“修订前的文件内容全文之逐行内容列表”的值并不是列表（Array）。\n`)

            return []
        }




        if (!其依赖包配置待处理的_packageJSON || typeof 其依赖包配置待处理的_packageJSON !== 'object') {
            console.error(`${
                本函数之一切消息之前缀
            }    ${
                粉笔工具.red('其依赖包配置待处理的_packageJSON 无效。')
            }其为：`, 其依赖包配置待处理的_packageJSON, '\n')

            return 修订前的文件内容全文之逐行内容列表
        }

        if (Array.isArray(其依赖包配置待处理的_packageJSON)) {
            应开启调试功能 && console.debug(`${
                本函数之一切消息之前缀
            }    package.json 的内容怎么可能是列表（Array）？\n`)

            return 修订前的文件内容全文之逐行内容列表
        }


        /** @type {范_通用的_packageJSON['dependencies']} */
        let packageJSON_中产品级依赖包的配置集 = 其依赖包配置待处理的_packageJSON['dependencies']

        if (!packageJSON_中产品级依赖包的配置集 || typeof packageJSON_中产品级依赖包的配置集 !== 'object') {
            packageJSON_中产品级依赖包的配置集 = null
        }

        if (Array.isArray(packageJSON_中产品级依赖包的配置集)) {
            应开启调试功能 && console.debug(`${
                本函数之一切消息之前缀
            }    package.json 中的【产品级】依赖包版本配置怎么可能是列表（Array）？\n`)

            return 修订前的文件内容全文之逐行内容列表
        }



        /** @type {范_通用的_packageJSON['devDependencies']} */
        let packageJSON_中研发级依赖包的配置集 = 其依赖包配置待处理的_packageJSON['devDependencies']

        if (!packageJSON_中研发级依赖包的配置集 || typeof packageJSON_中研发级依赖包的配置集 !== 'object') {
            packageJSON_中研发级依赖包的配置集 = null
        }

        if (Array.isArray(packageJSON_中研发级依赖包的配置集)) {
            应开启调试功能 && console.debug(`${
                本函数之一切消息之前缀
            }    package.json 中的【研发级】依赖包版本配置怎么可能是列表（Array）？\n`)

            return 修订前的文件内容全文之逐行内容列表
        }



        const 本工具集自身之名称 = 本工具集自身的_packageJSON.name

        if (本工具集自身之名称 !== 其依赖包配置待处理的_packageJSON.name && (待处理的依赖包之种类 === '研发级' || 待处理的依赖包之种类 === '所有')) {
            // const 本工具集自身之版本 = 本工具集自身的_packageJSON.version

            if (!packageJSON_中研发级依赖包的配置集) {
                packageJSON_中研发级依赖包的配置集 = {}
            }

            if (!(本工具集自身之名称 in packageJSON_中研发级依赖包的配置集)) {
                /**
                 * 在某 npm 项目（暂称甲）中安装本工具集刚完成时，
                 * npm 就会运行本工具的安装脚本。
                 * 此时，甲的 package.json 中往往还未提及本工具集。
                 */
                // packageJSON_中研发级依赖包的配置集[本工具集自身之名称] = `^${本工具集自身之版本}`
                packageJSON_中研发级依赖包的配置集[本工具集自身之名称] = 'latest'
            }
        }



        /** @type {范_通用的_packageJSON['dependencies'] & 范_通用的_packageJSON['devDependencies']} */
        let packageJSON_中本次所需处理的所有依赖包的配置集 = null

        if (待处理的依赖包之种类 === '产品级') {
            if (!packageJSON_中产品级依赖包的配置集) {
                return 修订前的文件内容全文之逐行内容列表
            }

            packageJSON_中本次所需处理的所有依赖包的配置集 = packageJSON_中产品级依赖包的配置集
        } else if (待处理的依赖包之种类 === '研发级') {
            if (!packageJSON_中研发级依赖包的配置集) {
                return 修订前的文件内容全文之逐行内容列表
            }

            packageJSON_中本次所需处理的所有依赖包的配置集 = packageJSON_中研发级依赖包的配置集
        } else if (待处理的依赖包之种类 === '所有') {
            if (!packageJSON_中产品级依赖包的配置集 && !packageJSON_中研发级依赖包的配置集) {
                return 修订前的文件内容全文之逐行内容列表
            }

            if (!packageJSON_中产品级依赖包的配置集) {
                packageJSON_中产品级依赖包的配置集 = {}
            }

            if (!packageJSON_中研发级依赖包的配置集) {
                packageJSON_中研发级依赖包的配置集 = {}
            }

            packageJSON_中本次所需处理的所有依赖包的配置集 = {
                ...packageJSON_中产品级依赖包的配置集,
                ...packageJSON_中研发级依赖包的配置集,
            }
        }



        if (typeof 在范文中引导插入或替换内容的标记文字_起始记号 !== 'string' || !在范文中引导插入或替换内容的标记文字_起始记号.trim()) {
            console.error(`${
                本函数之一切消息之前缀
            }    ${
                粉笔工具.red('在尝试自动搜集依赖包并写入命令行脚本文件时，')
            }\n    ${
                粉笔工具.red('给出的“作为引导内容插入或替换标记的文字”无效。')
            }\n    ${
                粉笔工具.red('给出的标记文字如下：')
            }\n        "${
                粉笔工具.yellow(在范文中引导插入或替换内容的标记文字_起始记号)
            }"\n`)

            return 修订前的文件内容全文之逐行内容列表
        }



        const 要用到结束记号 = !产出的内容确系用于PowerShell代码
        if (要用到结束记号) {
            if (typeof 在范文中引导插入或替换内容的标记文字_结束记号 !== 'string' || !在范文中引导插入或替换内容的标记文字_结束记号.trim()) {
                console.error(`${
                    本函数之一切消息之前缀
                }    ${
                    粉笔工具.red('在尝试自动搜集依赖包并写入命令行脚本文件时，')
                }\n    ${
                    粉笔工具.red('给出的“作为引导内容插入或替换标记的文字”无效。')
                }\n    ${
                    粉笔工具.red('给出的标记文字如下：')
                }\n        "${
                    粉笔工具.yellow(在范文中引导插入或替换内容的标记文字_结束记号)
                }"\n`)

                return 修订前的文件内容全文之逐行内容列表
            }
        } else {
            在范文中引导插入或替换内容的标记文字_结束记号 = null
        }



        /** @type {number[]} */
        const 匹配到起始记号的行的编号之列表 = 修订前的文件内容全文之逐行内容列表.reduce((_匹配到的行的编号之列表, 范文的某行, 该行的列表编号) => {
            const 该行与标记文字匹配 = 范文的某行.indexOf(在范文中引导插入或替换内容的标记文字_起始记号) >= 0
            if (该行与标记文字匹配) {
                _匹配到的行的编号之列表.push(该行的列表编号)
            }

            return _匹配到的行的编号之列表
        }, [])

        if (匹配到起始记号的行的编号之列表.length < 1) {

            console.error(`${
                本函数之一切消息之前缀
            }\n    ${
                粉笔工具.red('在尝试自动搜集依赖包并写入命令行脚本文件时，')
            }\n    ${
                粉笔工具.red('在原始范文中没有找到“作为引导内容插入或替换标记的文字”。')
            }\n    ${
                粉笔工具.red('给出的标记文字如下：')
            }\n        "${
                粉笔工具.yellow(在范文中引导插入或替换内容的标记文字_起始记号)
            }"`)

            return 修订前的文件内容全文之逐行内容列表

        } else if (匹配到起始记号的行的编号之列表.length > 1) {

            console.error(`${
                本函数之一切消息之前缀
            }\n    ${
                粉笔工具.red('在尝试自动搜集依赖包并写入命令行脚本文件时，')
            }\n    ${
                粉笔工具.red(`在原始范文中寻找“作为引导内容插入或替换标记的文字”时，找到${
                    粉笔工具.yellow(`不止一处，共 ${匹配到起始记号的行的编号之列表.length} 处`)
                }。`)
            }\n    ${
                粉笔工具.red('给出的标记文字如下：')
            }\n        "${
                粉笔工具.yellow(在范文中引导插入或替换内容的标记文字_起始记号)
            }"`)

            return 修订前的文件内容全文之逐行内容列表

        }



        /** @type {number[]} */
        let 匹配到结束记号的行的编号之列表 = []

        if (要用到结束记号) {

            匹配到结束记号的行的编号之列表 = 修订前的文件内容全文之逐行内容列表.reduce((_匹配到的行的编号之列表, 范文的某行, 该行的列表编号) => {
                const 该行与标记文字匹配 = 范文的某行.indexOf(在范文中引导插入或替换内容的标记文字_结束记号) >= 0
                if (该行与标记文字匹配) {
                    _匹配到的行的编号之列表.push(该行的列表编号)
                }

                return _匹配到的行的编号之列表
            }, [])



            if (匹配到结束记号的行的编号之列表.length < 1) {

                console.error(`${
                    本函数之一切消息之前缀
                }\n    ${
                    粉笔工具.red('在尝试自动搜集依赖包并写入命令行脚本文件时，')
                }\n    ${
                    粉笔工具.red('在原始范文中没有找到“作为引导内容插入或替换标记的文字”。')
                }\n    ${
                    粉笔工具.red('给出的标记文字如下：')
                }\n        "${
                    粉笔工具.yellow(在范文中引导插入或替换内容的标记文字_结束记号)
                }"`)

                return 修订前的文件内容全文之逐行内容列表

            } else if (匹配到结束记号的行的编号之列表.length > 1) {

                console.error(`${
                    本函数之一切消息之前缀
                }\n    ${
                    粉笔工具.red('在尝试自动搜集依赖包并写入命令行脚本文件时，')
                }\n    ${
                    粉笔工具.red(`在原始范文中寻找“作为引导内容插入或替换标记的文字”时，找到${
                        粉笔工具.yellow(`不止一处，共 ${匹配到结束记号的行的编号之列表.length} 处`)
                    }。`)
                }\n    ${
                    粉笔工具.red('给出的标记文字如下：')
                }\n        "${
                    粉笔工具.yellow(在范文中引导插入或替换内容的标记文字_结束记号)
                }"`)

                return 修订前的文件内容全文之逐行内容列表

            }

        }



        const 唯一匹配到的起始记号所在行的列表编号 = 匹配到起始记号的行的编号之列表[0]

        /** @type {string} */
        const 唯一匹配到的标记文字所在行的内容全文 = 修订前的文件内容全文之逐行内容列表[唯一匹配到的起始记号所在行的列表编号]
        const 唯一匹配到的标记文字所在行起始的空白的匹配结果 = 唯一匹配到的标记文字所在行的内容全文.match(/^\s*/)

        let 唯一匹配到的标记文字所在行起始的空白 = ''
        if (唯一匹配到的标记文字所在行起始的空白的匹配结果) {
            唯一匹配到的标记文字所在行起始的空白 = 唯一匹配到的标记文字所在行起始的空白的匹配结果[0]
        }
        // console.debug(`>>>>> 唯一匹配到的标记文字所在行起始的空白 = '${唯一匹配到的标记文字所在行起始的空白}'`)



        const 唯一匹配到的结束记号所在行的列表编号 = !要用到结束记号
            ? NaN
            : (匹配到结束记号的行的编号之列表[0] - 1) // 减去 1 ，是因为已知结束记号行的上方还有一行注释。





        /**
         * @param {string} 依赖包之名称
         * @param {'产品级' | '研发级'} 该依赖包之种类
         */
        function 构建单个依赖包的内容处理任务的简易配置项 (依赖包之名称, 该依赖包之种类) {
            let 该依赖包之版本配置 = packageJSON_中本次所需处理的所有依赖包的配置集[依赖包之名称]

            let 已知该版本已经锁定在某范围内 = false
            let 已知该依赖包不必安装 = false
            if (typeof 该依赖包之版本配置 === 'string') {
                if (/^(file|git|git+ssh|git+http|git+https|http|https):/i.test(该依赖包之版本配置)) {
                    已知该依赖包不必安装 = true
                } else if (/^=\d+/.test(该依赖包之版本配置)) {
                    已知该版本已经锁定在某范围内 = true
                }
            }

            if (!已知该版本已经锁定在某范围内) {
                该依赖包之版本配置 = 'latest'
            }

            return {
                该依赖包之名称: 依赖包之名称,
                该依赖包之版本配置,
                该依赖包之种类,
                已知该依赖包不必安装,
                已知该版本已经锁定在某范围内,
                该依赖包之名称附近须补足的空格数: 0,
                该依赖包之版本配置附近须补足的空格数: 0,
                该依赖包已经在脚本文件中提及但此次须改变其依赖类别: false,
                须改变依赖类别的代码行的原始内容: '',
            }
        }



        /**
         * @param {string} 原始代码行
         * @param {string} 依赖包之名称
         *
         * @returns {ReturnType<String['match']>}
         */
        function 在_Bash_原始代码某行中找到了某依赖包之配置 (原始代码行, 依赖包之名称) {
            const 依赖包之名称_可用于正则表达式 = 依赖包之名称.replace(/([/])/g, '\\$1')

            /** @type {Array<RegExp>} */
            const 正则表达式列表 = [
                new RegExp(`^\\s*(--某(产品|研发)级依赖包之版本配置)(=|\\s+)['"]\\s*${依赖包之名称_可用于正则表达式}[\\s|'"]`),
            ]

            /** @type {ReturnType<String['match']>} */
            let 第一个匹配的正则表达式的匹配之结果 = null

            正则表达式列表.some(某正则表达式 => {
                const 该正则表达式匹配之结果 = 原始代码行.match(某正则表达式)

                该正则表达式匹配之结果 && 应开启调试功能 && console.debug(`${
                    本函数之一切消息之前缀
                }>>>>> Bash 命令行中查找依赖包命令行参数的正则表达式：\n    ${
                    粉笔工具.bgCyan(某正则表达式)
                }。\n>>>>> Bash 命令行中已有该依赖包："${
                    粉笔工具.greenBright(依赖包之名称)
                }"？`, 该正则表达式匹配之结果, `\n>>>>> 该行代码为：\n   "${
                    粉笔工具.bgYellow.black(原始代码行)
                }"。\n<<<<<`)

                if (该正则表达式匹配之结果) {
                    第一个匹配的正则表达式的匹配之结果 = 该正则表达式匹配之结果
                    return true
                }
            })

            return 第一个匹配的正则表达式的匹配之结果
        }



        const 拟写入命令行脚本文件的内容的简易配置列表 = [
            ...Object.keys(packageJSON_中产品级依赖包的配置集).sort().map(某依赖包之名称 => {
                return 构建单个依赖包的内容处理任务的简易配置项(某依赖包之名称, '产品级')
            }),

            ...Object.keys(packageJSON_中研发级依赖包的配置集).sort().map(某依赖包之名称 => {
                return 构建单个依赖包的内容处理任务的简易配置项(某依赖包之名称, '研发级')
            }),
        ].filter(依赖包版本简易配置 => !依赖包版本简易配置.已知该依赖包不必安装)



        /** @type {number} */
        const 已知依赖包名称中最长者之字符数 = Math.max(
            ...拟写入命令行脚本文件的内容的简易配置列表.map(
                ({ 该依赖包之名称 }) => 该依赖包之名称.length
            )
        )

        /** @type {number} */
        const 已知依赖包版本配置中最长者之字符数 = Math.max(
            ...拟写入命令行脚本文件的内容的简易配置列表.map(
                ({ 该依赖包之版本配置 }) => 该依赖包之版本配置.length
            )
        )

        拟写入命令行脚本文件的内容的简易配置列表.forEach((某依赖包之简易配置) => {
            某依赖包之简易配置.该依赖包之名称附近须补足的空格数 = Math.max(0, 已知依赖包名称中最长者之字符数 - 某依赖包之简易配置.该依赖包之名称.length)
            某依赖包之简易配置.该依赖包之版本配置附近须补足的空格数 = Math.max(0, 已知依赖包版本配置中最长者之字符数 - 某依赖包之简易配置.该依赖包之版本配置.length)
        })



        /** @type {string[]} */
        let 须写入命令行脚本文件的内容的诸行之列表

        if (产出的内容确系用于PowerShell代码) {

            /** @type {string[]} */
            const 命令诸行 = 拟写入命令行脚本文件的内容的简易配置列表.map(({
                该依赖包之名称,
                该依赖包之名称附近须补足的空格数,
                已知该版本已经锁定在某范围内,
                该依赖包之版本配置,
            }) => {
                const 需写入的依赖包名称之文本 = `'${该依赖包之名称}'${' '.repeat(该依赖包之名称附近须补足的空格数)}`

                if (已知该版本已经锁定在某范围内) {
                    return `${需写入的依赖包名称之文本} = @('${该依赖包之版本配置}', (@('不妨在此填写该依赖包版本被锁定的原因。') -join ""))`
                } else {
                    return `${需写入的依赖包名称之文本} = $null`
                }
            }).map(须写入命令行脚本文件的某行内容 => {
                return `${唯一匹配到的标记文字所在行起始的空白}${须写入命令行脚本文件的某行内容}`
            })



            须写入命令行脚本文件的内容的诸行之列表 = [
                '',
                ...命令诸行,
            ]

        } else {

            /** @typedef {'--某产品级依赖包之版本配置' | '--某研发级依赖包之版本配置'} 范_bash_核心命令行之核心参数名 */

            const bash_在起始与结束记号之间的所有原始代码行 = 修订前的文件内容全文之逐行内容列表.slice(
                唯一匹配到的起始记号所在行的列表编号 + 1,
                唯一匹配到的结束记号所在行的列表编号
            )

            应开启调试功能 && console.debug(`${
                本函数之一切消息之前缀
            }>>>>> bash_在起始与结束记号之间的所有原始代码行：`, bash_在起始与结束记号之间的所有原始代码行, '\n<<<<<\n')

            const bash_核心命令行之代码首行 = 'Update-吴乐川更新当前_npm_项目的所有依赖包 \\'

            const 在起始与结束记号之间疑似符合_Bash_核心命令行的诸代码行之相对编号 = bash_在起始与结束记号之间的所有原始代码行.map((bash_原始代码某行, 该原始代码行的相对编号) => {
                if (/^\s*Update-吴乐川更新当前_npm_项目的所有依赖包\s+\\\s*$/.test(bash_原始代码某行)) {
                    return 该原始代码行的相对编号
                } else {
                    return -1
                }
            }).filter(行编号 => 行编号 >= 0)

            if (在起始与结束记号之间疑似符合_Bash_核心命令行的诸代码行之相对编号.length > 1) {
                console.error(`${
                    本函数之一切消息之前缀
                }\n    ${
                    粉笔工具.red('在尝试自动搜集依赖包并写入命令行脚本文件时，')
                }\n    ${
                    粉笔工具.red(`在原始范文中的起始记号和结束记号之间，找到${
                        粉笔工具.yellow(`不止一处，共 ${在起始与结束记号之间疑似符合_Bash_核心命令行的诸代码行之相对编号.length} 处`)
                    }核心命令行。`)
                }\n    ${
                    粉笔工具.red('上述所谓“核心命令行”如下：')
                }\n        "${
                    粉笔工具.yellow(bash_核心命令行之代码首行)
                }"`)

                return 修订前的文件内容全文之逐行内容列表
            }

            const 在原始范文中的起始记号和结束记号之间确实找到了核心命令行 = 在起始与结束记号之间疑似符合_Bash_核心命令行的诸代码行之相对编号.length === 1

            let 找到的旧有核心命令行的代码行的相对编号 = NaN
            if (在原始范文中的起始记号和结束记号之间确实找到了核心命令行) {
                找到的旧有核心命令行的代码行的相对编号 = 在起始与结束记号之间疑似符合_Bash_核心命令行的诸代码行之相对编号[0]
            }

            if (应开启调试功能) {
                console.debug(`${
                    本函数之一切消息之前缀
                }>>>>> Bash 在原始范文中的起始记号和结束记号之间确实找到了核心命令行：`, 在原始范文中的起始记号和结束记号之间确实找到了核心命令行)

                if (在原始范文中的起始记号和结束记号之间确实找到了核心命令行) {
                    console.debug(`该行代码如下：\n    "${
                        bash_在起始与结束记号之间的所有原始代码行[找到的旧有核心命令行的代码行的相对编号]
                    }"\n<<<<<\n\n`)
                }
            }

            /** @type {string[]} */
            const 原始范文中的核心命令行所占据的诸代码行 = []
            if (在原始范文中的起始记号和结束记号之间确实找到了核心命令行) {
                const 从核心命令行开始的诸行 = bash_在起始与结束记号之间的所有原始代码行.slice(
                    找到的旧有核心命令行的代码行的相对编号
                )

                // 应开启调试功能 && console.debug(`${
                //     本函数之一切消息之前缀
                // }>>>>> Bash 从核心命令行开始的诸行：`, 从核心命令行开始的诸行, '\n<<<<<\n\n')

                从核心命令行开始的诸行.some(bash_原始代码某行 => {
                    if (!bash_原始代码某行.trim() || /^\s*#/.test(bash_原始代码某行)) {
                        return true
                    } else {
                        原始范文中的核心命令行所占据的诸代码行.push(bash_原始代码某行)
                        return /[^\\]\s*$/.test(bash_原始代码某行)
                    }
                })

                应开启调试功能 && console.debug(`${
                    本函数之一切消息之前缀
                }>>>>> Bash 原始范文中的核心命令行所占据的诸代码行：`, 原始范文中的核心命令行所占据的诸代码行, '\n<<<<<\n')
            }



            let 确实须添加或修改的内容对应的简易配置列表 = 拟写入命令行脚本文件的内容的简易配置列表

            /** @type {string[]} */
            const bash_核心命令行非核心参数项的诸代码行但不包含首行 = []
            const bash_核心命令行是核心参数项的诸代码行 = []

            原始范文中的核心命令行所占据的诸代码行.slice(1).forEach(bash_原始代码某行 => {
                const 该行是核心参数项占据的行 = /--某(产品|研发)级依赖包之版本配置(\s+|=)['"]/.test(bash_原始代码某行)

                if (该行是核心参数项占据的行) {
                    bash_核心命令行是核心参数项的诸代码行.push(bash_原始代码某行)
                } else {
                    bash_核心命令行非核心参数项的诸代码行但不包含首行.push(bash_原始代码某行)
                }
            })

            const bash_核心命令行原封不动的核心参数代码行列表 = []

            if (在原始范文中的起始记号和结束记号之间确实找到了核心命令行) {
                确实须添加或修改的内容对应的简易配置列表 = 拟写入命令行脚本文件的内容的简易配置列表.filter(某依赖包内容处理任务对应的简易配置 => {
                    const { 该依赖包之名称, 该依赖包之种类 } = 某依赖包内容处理任务对应的简易配置
                    const 该依赖包已经出现在核心命令行的某参数当中 = bash_核心命令行是核心参数项的诸代码行.some(
                        bash_原始代码某行 => {
                            try {
                                const 匹配之结果 = 在_Bash_原始代码某行中找到了某依赖包之配置(bash_原始代码某行, 该依赖包之名称)

                                let 确实匹配且无须修订 = false

                                if (匹配之结果) {
                                    /** @type {范_bash_核心命令行之核心参数名} */
                                    const 正确的_bash_核心命令行之核心参数名 = 该依赖包之种类 === '产品级' ? '--某产品级依赖包之版本配置' : '--某研发级依赖包之版本配置'

                                    const 本次须改变依赖类别 = 匹配之结果[1] !== 正确的_bash_核心命令行之核心参数名
                                    某依赖包内容处理任务对应的简易配置.该依赖包已经在脚本文件中提及但此次须改变其依赖类别 = 本次须改变依赖类别

                                    if (本次须改变依赖类别) {
                                        某依赖包内容处理任务对应的简易配置.须改变依赖类别的代码行的原始内容 = bash_原始代码某行
                                    }

                                    确实匹配且无须修订 = !本次须改变依赖类别
                                }

                                if (确实匹配且无须修订) {
                                    bash_核心命令行原封不动的核心参数代码行列表.push(bash_原始代码某行)
                                }

                                return 确实匹配且无须修订
                            } catch (遭遇的异常) {
                                console.error(`\n\n${
                                    本函数之一切消息之前缀
                                } 遭遇的异常：`)
                                console.error(遭遇的异常)
                                console.error('')
                                return false
                            }
                        }
                    )

                    return !该依赖包已经出现在核心命令行的某参数当中
                })
            }

            // 应开启调试功能 && console.debug(`${
            //     本函数之一切消息之前缀
            // }>>>>> 确实须添加或修改的内容对应的简易配置列表：`, 确实须添加或修改的内容对应的简易配置列表.map(某简易配置 => 某简易配置.该依赖包之名称))
            // 应开启调试功能 && console.debug('<<<<<\n')



            /** @type {string[]} */
            const bash_核心命令行之诸新添代码行 = 确实须添加或修改的内容对应的简易配置列表.map((依赖包版本简易配置, 编号) => {
                const {
                    该依赖包之名称,

                    该依赖包之种类,
                    该依赖包之版本配置,
                    已知该版本已经锁定在某范围内,
                    该依赖包之名称附近须补足的空格数,
                    该依赖包之版本配置附近须补足的空格数,

                    该依赖包已经在脚本文件中提及但此次须改变其依赖类别,
                    须改变依赖类别的代码行的原始内容,
                } = 依赖包版本简易配置

                const 参数值中需写入的依赖包名称之文本 = `${' '.repeat(该依赖包之名称附近须补足的空格数)}${该依赖包之名称}`
                const 参数值中需写入的依赖包之版本配置之文本 = `${该依赖包之版本配置}${' '.repeat(该依赖包之版本配置附近须补足的空格数)}`

                const 为令_Bash_代码美观易读而在分割符两侧的某一侧保留该空白 = ' '.repeat(3)

                let 参数值中需写入的的额外内容 = ''
                if (已知该版本已经锁定在某范围内) {
                    参数值中需写入的的额外内容 = `${
                        为令_Bash_代码美观易读而在分割符两侧的某一侧保留该空白
                    }${
                        在_Bash_命令行中用作关键配置中的分割符的文本记号
                    }${
                        为令_Bash_代码美观易读而在分割符两侧的某一侧保留该空白
                    }不妨说明该依赖包版本被锁定的原因。且可占据多行。`
                } else {
                    参数值中需写入的的额外内容 = `${
                        为令_Bash_代码美观易读而在分割符两侧的某一侧保留该空白
                    }${
                        在_Bash_命令行中用作关键配置中的分割符的文本记号
                    }`
                }



                /** @type {范_bash_核心命令行之核心参数名} */
                let bash_核心命令行之核心参数名

                if        (该依赖包之种类 === '产品级') {
                    bash_核心命令行之核心参数名 = '--某产品级依赖包之版本配置'
                } else if (该依赖包之种类 === '研发级') {
                    bash_核心命令行之核心参数名 = '--某研发级依赖包之版本配置'
                } else {
                    throw new Error(`${
                        本函数之一切消息之前缀
                    } 遭遇错误： 某依赖包之种类不合规。该不合规值为 "${该依赖包之种类}"。`)
                }



                if (该依赖包已经在脚本文件中提及但此次须改变其依赖类别) {
                    const bash_命令行之该代码行 = 须改变依赖类别的代码行的原始内容.replace(/--某(产品|研发)级依赖包之版本配置/, bash_核心命令行之核心参数名)
                    return bash_命令行之该代码行
                } else {
                    return`${
                        唯一匹配到的标记文字所在行起始的空白
                    }${
                        ' '.repeat(4)
                    }${
                        bash_核心命令行之核心参数名
                    } "${
                        参数值中需写入的依赖包名称之文本
                    }${
                        为令_Bash_代码美观易读而在分割符两侧的某一侧保留该空白
                    }${
                        在_Bash_命令行中用作关键配置中的分割符的文本记号
                    }${
                        为令_Bash_代码美观易读而在分割符两侧的某一侧保留该空白
                    }${
                        参数值中需写入的依赖包之版本配置之文本
                    }${
                        参数值中需写入的的额外内容
                    }" \\`
                }
            })

            应开启调试功能 && console.debug(`${
                本函数之一切消息之前缀
            }>>>>> bash_核心命令行之诸新添代码行：`, bash_核心命令行之诸新添代码行)
            应开启调试功能 && console.debug('<<<<<\n')

            应开启调试功能 && console.debug(`${
                本函数之一切消息之前缀
            }>>>>> bash_核心命令行非核心参数项的诸代码行但不包含首行：`, bash_核心命令行非核心参数项的诸代码行但不包含首行)
            应开启调试功能 && console.debug('<<<<<\n')

            应开启调试功能 && console.debug(`${
                本函数之一切消息之前缀
            }>>>>> bash_核心命令行原封不动的核心参数代码行列表：`, bash_核心命令行原封不动的核心参数代码行列表)
            应开启调试功能 && console.debug('<<<<<\n')



            if (bash_核心命令行之诸新添代码行.length > 0) {

                /** @type {string[]} */
                let bash_核心命令行之所有核心参数项占据的诸代码行 = []

                /** @type {string[]} */
                let bash_核心命令行之首部诸代码行 = []

                /** @type {string[]} */
                let bash_核心命令行之尾部诸代码行 = []

                let 应对核心参数项诸代码行排序 = false



                if (在原始范文中的起始记号和结束记号之间确实找到了核心命令行) {
                    bash_核心命令行之首部诸代码行 = [
                        // 原始范文中的核心命令行所占据的诸代码行[0],
                    ]

                    bash_核心命令行之所有核心参数项占据的诸代码行 = [
                        ...bash_核心命令行之诸新添代码行,
                        ...bash_核心命令行原封不动的核心参数代码行列表,
                    ]
                    应对核心参数项诸代码行排序 = true

                    bash_核心命令行之尾部诸代码行 = [
                        ...bash_核心命令行非核心参数项的诸代码行但不包含首行,
                    ]
                } else {
                    bash_核心命令行之首部诸代码行 = [
                        '',
                        bash_核心命令行之代码首行,
                    ].map(尚未整体统一缩进的代码行 => {
                        if (!尚未整体统一缩进的代码行.trim()) { return '' }
                        return `${唯一匹配到的标记文字所在行起始的空白}${尚未整体统一缩进的代码行}`
                    })

                    bash_核心命令行之所有核心参数项占据的诸代码行 = [
                        ...bash_核心命令行之诸新添代码行,
                    ]

                    bash_核心命令行之尾部诸代码行 = [
                        `    --内容分割记号='${在_Bash_命令行中用作关键配置中的分割符的文本记号}' \\`,
                        '    --NPM安装依赖包时须额外带上的参数序列="$NpmArguments" \\',
                        '    --调试功能之级别 0 \\',
                        '    --应仅作仿真演练 false',
                        // '',
                    ].map(尚未整体统一缩进的代码行 => {
                        if (!尚未整体统一缩进的代码行.trim()) { return '' }
                        return `${唯一匹配到的标记文字所在行起始的空白}${尚未整体统一缩进的代码行}`
                    })
                }



                if (应对核心参数项诸代码行排序) {
                    bash_核心命令行之所有核心参数项占据的诸代码行.sort((bash_代码行甲, bash_代码行乙) => {
                        const 甲匹配核心一类参数之结论 = bash_代码行甲.match(/--某产品级依赖包之版本配置(\s+|=)['"]\s*(\S+)/)
                        const 甲匹配核心二类参数之结论 = bash_代码行甲.match(/--某研发级依赖包之版本配置(\s+|=)['"]\s*(\S+)/)

                        const 乙匹配核心一类参数之结论 = bash_代码行乙.match(/--某产品级依赖包之版本配置(\s+|=)['"]\s*(\S+)/)
                        const 乙匹配核心二类参数之结论 = bash_代码行乙.match(/--某研发级依赖包之版本配置(\s+|=)['"]\s*(\S+)/)

                        if (甲匹配核心一类参数之结论 && 乙匹配核心二类参数之结论) { return -1 }
                        if (甲匹配核心二类参数之结论 && 乙匹配核心一类参数之结论) { return 1 }

                        let 甲中之依赖包名 = ''
                        let 乙中之依赖包名 = ''

                        if (甲匹配核心一类参数之结论 && 乙匹配核心一类参数之结论) {
                            甲中之依赖包名 = 甲匹配核心一类参数之结论[2]
                            乙中之依赖包名 = 乙匹配核心一类参数之结论[2]
                        } else if (甲匹配核心二类参数之结论 && 乙匹配核心二类参数之结论) {
                            甲中之依赖包名 = 甲匹配核心二类参数之结论[2]
                            乙中之依赖包名 = 乙匹配核心二类参数之结论[2]
                        }

                        return 甲中之依赖包名 > 乙中之依赖包名 ? 1 : -1
                    })
                }



                /** @type {string[]} */
                const bash_须插入命令行脚本文件的诸代码行 = [
                    ...bash_核心命令行之首部诸代码行,
                    ...bash_核心命令行之所有核心参数项占据的诸代码行,
                    ...bash_核心命令行之尾部诸代码行,
                ]



                if (在原始范文中的起始记号和结束记号之间确实找到了核心命令行) {
                    须写入命令行脚本文件的内容的诸行之列表 = [
                        ...bash_在起始与结束记号之间的所有原始代码行.slice(0, 找到的旧有核心命令行的代码行的相对编号 + 1),
                        ...bash_须插入命令行脚本文件的诸代码行,
                        ...bash_在起始与结束记号之间的所有原始代码行.slice(   找到的旧有核心命令行的代码行的相对编号 + 原始范文中的核心命令行所占据的诸代码行.length),
                    ]
                } else {
                    须写入命令行脚本文件的内容的诸行之列表 = [
                        ...bash_在起始与结束记号之间的所有原始代码行.slice(0, 找到的旧有核心命令行的代码行的相对编号 + 1),
                        ...bash_须插入命令行脚本文件的诸代码行,
                        ...bash_在起始与结束记号之间的所有原始代码行.slice(   找到的旧有核心命令行的代码行的相对编号 + 1),
                    ]
                }
                // if (在原始范文中的起始记号和结束记号之间确实找到了核心命令行) {
                //     须写入命令行脚本文件的内容的诸行之列表 = [
                //         ...bash_在起始与结束记号之间的所有原始代码行.slice(0, 找到的旧有核心命令行的代码行的相对编号 + 1),
                //         ...bash_须插入命令行脚本文件的诸代码行,
                //         ...bash_在起始与结束记号之间的所有原始代码行.slice(   找到的旧有核心命令行的代码行的相对编号 + 1),
                //     ]
                // } else {
                //     须写入命令行脚本文件的内容的诸行之列表 = bash_须插入命令行脚本文件的诸代码行
                // }

            } else {

                须写入命令行脚本文件的内容的诸行之列表 = []

            }



            应开启调试功能 && console.debug(`${
                本函数之一切消息之前缀
            }>>>>> 须写入命令行脚本文件的内容的诸行之列表：`, 须写入命令行脚本文件的内容的诸行之列表)
            应开启调试功能 && console.debug('<<<<<\n')

        } // 这是 if (产出的内容确系用于PowerShell代码) 配对的 else 的终点。



        if (Array.isArray(须写入命令行脚本文件的内容的诸行之列表) && 须写入命令行脚本文件的内容的诸行之列表.length > 0) {

            /** @type {string[]} */
            let 修订好的内容全文之诸行列表

            if (产出的内容确系用于PowerShell代码) {
                修订好的内容全文之诸行列表 = [
                    ...修订前的文件内容全文之逐行内容列表.slice(0, 唯一匹配到的起始记号所在行的列表编号 + 1),
                    ...须写入命令行脚本文件的内容的诸行之列表,
                    ...修订前的文件内容全文之逐行内容列表.slice(   唯一匹配到的起始记号所在行的列表编号 + 1),
                ]
            } else {
                修订好的内容全文之诸行列表 = [
                    ...修订前的文件内容全文之逐行内容列表.slice(0, 唯一匹配到的起始记号所在行的列表编号 + 1),
                    ...须写入命令行脚本文件的内容的诸行之列表,
                    ...修订前的文件内容全文之逐行内容列表.slice(   唯一匹配到的结束记号所在行的列表编号),
                ]
            }



            // 应开启调试功能 && console.debug(`${
            //     本函数之一切消息之前缀
            // }>>>>> 修订好的内容全文之诸行列表`, 修订好的内容全文之诸行列表)
            // 应开启调试功能 && console.debug('<<<<<\n')

            return 修订好的内容全文之诸行列表
        } else {
            应开启调试功能 && console.debug(`${
                本函数之一切消息之前缀
            }>>>>> 该脚本文件无须添加代码行。<<<<<\n`)

            return 修订前的文件内容全文之逐行内容列表
        }
    }
}
