/**
 * @typedef {import('chalk').ChalkInstance} 范_粉笔工具
 */

/**
 * @typedef {import('node:path')} 范_路径工具
 */

/**
 * @typedef {import('fs-extra')} 范_文件系统工具之扩展版
 */

/**
 * @typedef {import('../辅助工具集')} 范_本工具集随附之辅助工具集
 */

/**
 * @typedef {import('./0-常量表')} 范_本工具集之内部常量表
 */

/**
 * @typedef {import('../../../package.json')} 范_本工具集自身的_packageJSON
 */

/**
 * @typedef {import('../../../package.json')} 范_通用的_packageJSON # 这里假借本工具集自身的 package.json 来表征通用 package.json 的类型定义。因为真正的通用类型定义暂未找到，而假借的这一类型定义也够用了。
 */





/**
 * @param {object}                        配置项集
 *
 * @param {boolean}                       配置项集.应开启调试功能
 *
 * @param {范_粉笔工具}                   配置项集.粉笔工具
 * @param {范_路径工具}                   配置项集.路径工具
 * @param {范_文件系统工具之扩展版}       配置项集.文件系统工具之扩展版
 *
 * @param {范_本工具集随附之辅助工具集}   配置项集.本工具集随附之辅助工具集
 *
 * @param {string}                        配置项集.本工具集一切命令行消息之前缀
 * @param {string}                        配置项集.本工具集自身根文件夹之完整路径
 * @param {范_本工具集自身的_packageJSON} 配置项集.本工具集自身的_packageJSON
 *
 * @param {string}                        配置项集.视作须为其安装本工具集的_npm_项目的根文件的完整路径
 * @param {范_通用的_packageJSON}         配置项集.视作须为其安装本工具集的_npm_项目的_packageJSON
 * @param {string}                        配置项集.用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径
 * @param {string}                        配置项集.本工具集随附命令行应用范本集文件夹之相对路径
 * @param {string}                        配置项集.用于研发阶段的命令行工具集_这一文件夹之相对路径
 * @param {boolean}                       配置项集.发布本工具集随附的命令行脚本时_个别脚本文件应发布在目标项目之根文件夹下
 * @param {boolean}                       配置项集.发布本工具集随附的命令行脚本时应覆盖旧有的命令行脚本文件
 * @param {boolean}                       配置项集.发布本工具集随附的命令行脚本时若覆盖旧有的命令行脚本文件则先行备份
 *
 * @returns {Promise<any>}
 */
module.exports = function 将本工具集随附命令行应用范本文件发布至采用本工具集的_npm_包中去 ({
    应开启调试功能,

    粉笔工具,
    路径工具,
    文件系统工具之扩展版,

    本工具集随附之辅助工具集,

    本工具集一切命令行消息之前缀,
    本工具集自身根文件夹之完整路径,
    本工具集自身的_packageJSON,

    视作须为其安装本工具集的_npm_项目的根文件的完整路径,
    视作须为其安装本工具集的_npm_项目的_packageJSON,
    用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径,
    本工具集随附命令行应用范本集文件夹之相对路径,
    用于研发阶段的命令行工具集_这一文件夹之相对路径,
    发布本工具集随附的命令行脚本时_个别脚本文件应发布在目标项目之根文件夹下,
    发布本工具集随附的命令行脚本时应覆盖旧有的命令行脚本文件,
    发布本工具集随附的命令行脚本时若覆盖旧有的命令行脚本文件则先行备份,
} = {}) {
    应开启调试功能 && console.debug('>>>> 将本工具集随附命令行应用范本文件发布至采用本工具集的_npm_包中去 <<<<')

    if (typeof 视作须为其安装本工具集的_npm_项目的根文件的完整路径 !== 'string' || !视作须为其安装本工具集的_npm_项目的根文件的完整路径.trim()) {
        return Promise.reject(new Error(`${
            本工具集一切命令行消息之前缀
        }\n    ${
            粉笔工具.red(`没有给出【${
                粉笔工具.yellow('视作须为其安装本工具集的_npm_项目的根文件的完整路径')
            }】。`)
        }\n`))
    }

    return Promise.all([
        import('./0-常量表.js'),
    ]).then(([
        本工具集之内部常量表_模块,
    ]) => {
        应开启调试功能 && console.debug('>>>> 将本工具集随附命令行应用范本文件发布至采用本工具集的_npm_包中去 then <<<<')

        /** @type {范_本工具集之内部常量表} */
        const 本工具集之内部常量表 = 本工具集之内部常量表_模块.default

        发布命令行脚本之范本集_主体功能({
            应开启调试功能,

            粉笔工具,
            路径工具,
            文件系统工具之扩展版,

            本工具集随附之辅助工具集,
            本工具集之内部常量表,

            本工具集一切命令行消息之前缀,
            本工具集自身根文件夹之完整路径,
            本工具集自身的_packageJSON,

            视作须为其安装本工具集的_npm_项目的根文件的完整路径,
            视作须为其安装本工具集的_npm_项目的_packageJSON,
            用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径,
            本工具集随附命令行应用范本集文件夹之相对路径,
            用于研发阶段的命令行工具集_这一文件夹之相对路径,
            发布本工具集随附的命令行脚本时_个别脚本文件应发布在目标项目之根文件夹下,
            发布本工具集随附的命令行脚本时应覆盖旧有的命令行脚本文件,
            发布本工具集随附的命令行脚本时若覆盖旧有的命令行脚本文件则先行备份,
        })
    })
}





/**
 * @typedef {object} 范_命令行脚本文件之发布任务配置
 *
 * @property {boolean} 应尝试部署该文件
 * @property {boolean} 不论是否部署该文件也应尝试修订旧有文件
 * @property {string}  原始范本文件的二次相对路径
 * @property {string}  拟将范本文件发布于其中的文件夹的相对路径
 */





/**
 * @param {object}                        配置项集
 *
 * @param {boolean}                       配置项集.应开启调试功能
 *
 * @param {范_粉笔工具}                   配置项集.粉笔工具
 * @param {范_路径工具}                   配置项集.路径工具
 * @param {范_文件系统工具之扩展版}       配置项集.文件系统工具之扩展版
 *
 * @param {范_本工具集随附之辅助工具集}   配置项集.本工具集随附之辅助工具集
 * @param {范_本工具集之内部常量表}       配置项集.本工具集之内部常量表
 *
 * @param {string}                        配置项集.本工具集一切命令行消息之前缀
 * @param {string}                        配置项集.本工具集自身根文件夹之完整路径
 * @param {范_本工具集自身的_packageJSON} 配置项集.本工具集自身的_packageJSON
 *
 * @param {string}                        配置项集.视作须为其安装本工具集的_npm_项目的根文件的完整路径
 * @param {范_通用的_packageJSON}         配置项集.视作须为其安装本工具集的_npm_项目的_packageJSON
 * @param {string}                        配置项集.用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径
 * @param {string}                        配置项集.本工具集随附命令行应用范本集文件夹之相对路径      - 默认值为 '源代码/命令行应用范本集' 。
 * @param {string}                        配置项集.用于研发阶段的命令行工具集_这一文件夹之相对路径     - 默认值为 '用于研发阶段的命令行工具集' 。
 * @param {boolean}                       配置项集.发布本工具集随附的命令行脚本时_个别脚本文件应发布在目标项目之根文件夹下
 * @param {boolean}                       配置项集.发布本工具集随附的命令行脚本时应覆盖旧有的命令行脚本文件
 * @param {boolean}                       配置项集.发布本工具集随附的命令行脚本时若覆盖旧有的命令行脚本文件则先行备份
 */
function 发布命令行脚本之范本集_主体功能 ({
    应开启调试功能,

    粉笔工具,
    路径工具,
    文件系统工具之扩展版,

    本工具集随附之辅助工具集,
    本工具集之内部常量表,

    本工具集一切命令行消息之前缀,
    本工具集自身根文件夹之完整路径,
    本工具集自身的_packageJSON,

    视作须为其安装本工具集的_npm_项目的根文件的完整路径,
    视作须为其安装本工具集的_npm_项目的_packageJSON,
    用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径,
    本工具集随附命令行应用范本集文件夹之相对路径,
    用于研发阶段的命令行工具集_这一文件夹之相对路径,
    // 发布本工具集随附的命令行脚本时_个别脚本文件应发布在目标项目之根文件夹下,
    发布本工具集随附的命令行脚本时应覆盖旧有的命令行脚本文件,
    发布本工具集随附的命令行脚本时若覆盖旧有的命令行脚本文件则先行备份,
}) {
    应开启调试功能 && console.debug('>>>> 发布命令行脚本之范本集_主体功能 <<<<')

    const {
        用于研发阶段的命令行工具集_这一文件夹之相对路径_默认值,
    } = 本工具集之内部常量表



    if (typeof 本工具集随附命令行应用范本集文件夹之相对路径 !== 'string' || !本工具集随附命令行应用范本集文件夹之相对路径.trim()) {
        本工具集随附命令行应用范本集文件夹之相对路径 = '源代码/命令行应用范本集'
    }

    if (typeof 用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径 !== 'string' || !用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径.trim()) {
        用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径 = 视作须为其安装本工具集的_npm_项目的根文件的完整路径
    }

    /** @type {string} */
    let 用于研发阶段的命令行工具集_这一文件夹之相对路径_采纳值
    if (typeof 用于研发阶段的命令行工具集_这一文件夹之相对路径 !== 'string' || !用于研发阶段的命令行工具集_这一文件夹之相对路径.trim()) {
        用于研发阶段的命令行工具集_这一文件夹之相对路径_采纳值 = 用于研发阶段的命令行工具集_这一文件夹之相对路径_默认值
    } else {
        用于研发阶段的命令行工具集_这一文件夹之相对路径_采纳值 = 用于研发阶段的命令行工具集_这一文件夹之相对路径
    }

    console.info(`\n\n\n\n\n${
        本工具集一切命令行消息之前缀
    } ${
        粉笔工具.bgGreenBright.black(' 现在开始发布各命令行脚本 ')
    } 。\n`)

    console.log(`\n${
        本工具集一切命令行消息之前缀
    }\n\n    视作须为其安装本工具集的_npm_项目的根文件的完整路径：\n    "${
        粉笔工具.green(视作须为其安装本工具集的_npm_项目的根文件的完整路径)
    }"\n\n    用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径：\n    "${
        粉笔工具.green(用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径)
    }"\n`)

    // console.info(
    //     '    个别脚本文件应发布在目标项目之根文件夹下：\n   ',
    //     发布本工具集随附的命令行脚本时_个别脚本文件应发布在目标项目之根文件夹下,
    //     '\n'
    // )



    /** @type {Array<范_命令行脚本文件之发布任务配置>} */
    const 所有命令行脚本文件之发布任务配置集 = [
        {
            应尝试部署该文件:                         true,
            不论是否部署该文件也应尝试修订旧有文件:   true,
            原始范本文件的二次相对路径:               路径工具.join('PowerShell', 'Update-更新所有-npm-依赖包至允许范围内的最新版本.ps1'),
            拟将范本文件发布于其中的文件夹的相对路径: 路径工具.join(用于研发阶段的命令行工具集_这一文件夹之相对路径_采纳值, 'PowerShell'),
        },

        {
            应尝试部署该文件:                         true,
            不论是否部署该文件也应尝试修订旧有文件:   true,
            原始范本文件的二次相对路径:               路径工具.join('bash', 'update-更新所有-npm-依赖包至允许范围内的最新版本.sh'),
            拟将范本文件发布于其中的文件夹的相对路径: 路径工具.join(用于研发阶段的命令行工具集_这一文件夹之相对路径_采纳值, 'bash'),
        },
    ].filter(任务 => !!任务)



    // 为了日志清晰、有序、易读，我最终还是舍弃了 Promsie.all 或 Promsie.allSettled 的做法，改为顺次执行各功能。
    所有命令行脚本文件之发布任务配置集.forEach(某命令行脚本文件之发布任务配置 => {
        try {
            发布某脚本文件({
                应开启调试功能,

                粉笔工具,
                路径工具,
                文件系统工具之扩展版,

                本工具集随附之辅助工具集,
                本工具集之内部常量表,

                本工具集一切命令行消息之前缀,
                本工具集自身根文件夹之完整路径,
                本工具集自身的_packageJSON,

                本工具集随附命令行应用范本集文件夹之相对路径,
                用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径,
                用于研发阶段的命令行工具集_这一文件夹之相对路径: 用于研发阶段的命令行工具集_这一文件夹之相对路径_采纳值,
                发布本工具集随附的命令行脚本时应覆盖旧有的命令行脚本文件,
                发布本工具集随附的命令行脚本时若覆盖旧有的命令行脚本文件则先行备份,

                某命令行脚本文件之发布任务配置,

                视作须为其安装本工具集的_npm_项目的_packageJSON,
            })
        } catch (异常之记载) {
            console.error(`\n\n${
                本工具集一切命令行消息之前缀
            }\n${
                粉笔工具.bgRed.white(' 遭遇异常 ')
            }：\n${
                粉笔工具.red(异常之记载.message || 异常之记载)
            }\n\n`)
        }
    })





    /**
     * @param {object}                          配置项集
     *
     * @param {boolean}                         配置项集.应开启调试功能
     *
     * @param {范_粉笔工具}                     配置项集.粉笔工具
     * @param {范_路径工具}                     配置项集.路径工具
     * @param {范_文件系统工具之扩展版}         配置项集.文件系统工具之扩展版
     *
     * @param {范_本工具集随附之辅助工具集}     配置项集.本工具集随附之辅助工具集
     * @param {范_本工具集之内部常量表}         配置项集.本工具集之内部常量表
     *
     * @param {string}                          配置项集.本工具集一切命令行消息之前缀
     * @param {string}                          配置项集.本工具集自身根文件夹之完整路径
     * @param {范_本工具集自身的_packageJSON}   配置项集.本工具集自身的_packageJSON
     *
     * @param {string}                          配置项集.本工具集随附命令行应用范本集文件夹之相对路径
     * @param {string}                          配置项集.用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径
     * @param {string}                          配置项集.用于研发阶段的命令行工具集_这一文件夹之相对路径
     * @param {boolean}                         配置项集.发布本工具集随附的命令行脚本时应覆盖旧有的命令行脚本文件
     * @param {boolean}                         配置项集.发布本工具集随附的命令行脚本时若覆盖旧有的命令行脚本文件则先行备份
     *
     * @param {范_命令行脚本文件之发布任务配置} 配置项集.某命令行脚本文件之发布任务配置
     *
     * @param {范_通用的_packageJSON}           配置项集.视作须为其安装本工具集的_npm_项目的_packageJSON
     */
    function 发布某脚本文件 ({
        应开启调试功能,

        粉笔工具,
        路径工具,
        文件系统工具之扩展版,

        本工具集随附之辅助工具集,
        本工具集之内部常量表,

        本工具集一切命令行消息之前缀,
        本工具集自身根文件夹之完整路径,
        本工具集自身的_packageJSON,

        本工具集随附命令行应用范本集文件夹之相对路径,
        用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径,
        用于研发阶段的命令行工具集_这一文件夹之相对路径,
        发布本工具集随附的命令行脚本时应覆盖旧有的命令行脚本文件,
        发布本工具集随附的命令行脚本时若覆盖旧有的命令行脚本文件则先行备份,

        某命令行脚本文件之发布任务配置,

        视作须为其安装本工具集的_npm_项目的_packageJSON,
    } = {}) {
        const 拼接路径片段 = 路径工具.join
        const 求完整路径 = 路径工具.resolve
        const 求路径中的文件之文件全名 = 路径工具.basename
        const 求路径末端实体的容纳文件夹之路径 = 路径工具.dirname



        const {
            用于研发阶段的命令行工具集_这一文件夹之相对路径_默认值,
            在_PowerShell_命令行范本中需替换为当前_npm_的_产品级_依赖包列表的占位文本,
            在_PowerShell_命令行范本中需替换为当前_npm_的_研发级_依赖包列表的占位文本,
            在_Bash_命令行范本中需替换为当前_npm_的_产品级_依赖包列表的占位文本_凡可自由采用其版本者,
            在_Bash_命令行范本中需替换为当前_npm_的_产品级_依赖包列表的占位文本_凡须锁定其版本范围者,
            在_Bash_命令行范本中需替换为当前_npm_的_研发级_依赖包列表的占位文本_凡可自由采取其版本者,
            在_Bash_命令行范本中需替换为当前_npm_的_研发级_依赖包列表的占位文本_凡须锁定其版本范围者,
        } = 本工具集之内部常量表



        const {
            应尝试部署该文件,
            不论是否部署该文件也应尝试修订旧有文件,
            原始范本文件的二次相对路径,
            拟将范本文件发布于其中的文件夹的相对路径,
        } = 某命令行脚本文件之发布任务配置

        if (!应尝试部署该文件 && !不论是否部署该文件也应尝试修订旧有文件) {
            return
        }



        const 命令行脚本文件之文件名 = 求路径中的文件之文件全名(原始范本文件的二次相对路径)
        const 该命令行脚本文件确系PowerShell = /\.psm?1$/.test(命令行脚本文件之文件名)
        const 原始范本文件的一次相对路径 = 拼接路径片段(本工具集随附命令行应用范本集文件夹之相对路径, 原始范本文件的二次相对路径)
        const 容纳原始范本文件之文件夹之完整路径 = 求完整路径(求路径末端实体的容纳文件夹之路径(原始范本文件的一次相对路径))

        const 原始范本文件之完整路径 = 求完整路径(拼接路径片段(
            本工具集自身根文件夹之完整路径,
            本工具集随附命令行应用范本集文件夹之相对路径,
            原始范本文件的二次相对路径
        ))

        const 容纳发布的文件的文件夹之完整路径 = 求完整路径(拼接路径片段(
            用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径,
            拟将范本文件发布于其中的文件夹的相对路径
        ))

        const 拟发布成为之文件之完整路径 = 拼接路径片段(
            容纳发布的文件的文件夹之完整路径,
            命令行脚本文件之文件名
        )



        let 范文确实存在 = false
        if (文件系统工具之扩展版.existsSync(原始范本文件之完整路径)) {
            const 文件描述符 = 文件系统工具之扩展版.statSync(原始范本文件之完整路径)
            if (文件描述符.isFile()) {
                范文确实存在 = true
            }
        }



        let 欲发布的文件业已存在 = false
        if (文件系统工具之扩展版.existsSync(拟发布成为之文件之完整路径)) {
            const 文件描述符 = 文件系统工具之扩展版.statSync(拟发布成为之文件之完整路径)
            if (文件描述符.isFile()) {
                欲发布的文件业已存在 = true
            }
        }



        let 确应发布或覆盖该文件 = false
        let 确应保存备份文件 = false

        if (应尝试部署该文件) {

            if (!范文确实存在) {
                console.error(`${
                    本工具集一切命令行消息之前缀
                }\n${
                    粉笔工具.red('欲部署某命令行脚本工具时，未找到原始文件。已略过该部署任务。')
                }\n所涉文件之描述如下：\n    相对路径： "${
                    粉笔工具.redBright(原始范本文件的二次相对路径)
                }"\n    完整路径： "${
                    粉笔工具.redBright(原始范本文件之完整路径)
                }"\n`)



                return
            }



            console[欲发布的文件业已存在 ? 'warn' : 'log'](`${
                本工具集一切命令行消息之前缀
            }\n\n    找到原始的命令行脚本${粉笔工具.cyanBright('范本')}：\n    "${
                粉笔工具.white(`${容纳原始范本文件之文件夹之完整路径}${路径工具.sep}`)
            }${
                粉笔工具.cyan(命令行脚本文件之文件名)
            }"\n`)

            console[欲发布的文件业已存在 ? 'warn' : 'log'](`    ${
                粉笔工具.yellow('拟发布为：')
            }：\n    "${
                粉笔工具.green(`${容纳发布的文件的文件夹之完整路径}${路径工具.sep}`)
            }${
                粉笔工具.greenBright(命令行脚本文件之文件名)
            }"\n`)




            if (欲发布的文件业已存在) {
                console.warn(`   ${
                    粉笔工具.bgYellow.black(' 欲发布的命令行脚本文件业已存在 ')
                } 。`)
                // console.warn(`    ${
                //     粉笔工具.yellow('欲发布的命令行脚本文件业已存在')
                // }：\n    "${
                //     粉笔工具.blue(`${容纳发布的文件的文件夹之完整路径}${路径工具.sep}`)
                // }${
                //     粉笔工具.blueBright(命令行脚本文件之文件名)
                // }"\n`)

                if (发布本工具集随附的命令行脚本时应覆盖旧有的命令行脚本文件) {
                    确应发布或覆盖该文件 = true
                    确应保存备份文件 = !!发布本工具集随附的命令行脚本时若覆盖旧有的命令行脚本文件则先行备份

                    if (确应保存备份文件) {
                        console.warn(`   ${粉笔工具.bgMagenta.black(' 该文件将被覆盖，但会先行备份 ')} 。`)
                    } else {
                        console.warn(`   ${粉笔工具.bgRed.whiteBright(' 该文件将被覆盖，且不会先行备份 ')} 。`)
                    }
                } else {
                    确应发布或覆盖该文件 = false
                    确应保存备份文件 = false

                    console.warn(`   ${粉笔工具.bgGreen.black(' 不会发布新文件，而是保留旧有文件 ')} 。\n`)
                }
            } else {
                确应发布或覆盖该文件 = true
                确应保存备份文件 = false
            }

        }





        if (确应发布或覆盖该文件) {

            文件系统工具之扩展版.mkdirpSync(容纳发布的文件的文件夹之完整路径)



            if (确应保存备份文件) {
                const 该命令行脚本文件之扩展名 = 路径工具.extname(命令行脚本文件之文件名)
                const 时间戳 = 本工具集随附之辅助工具集.求当前时间之文本_可用于文件系统之文件名()

                const 备份文件之文件名 = `${
                    路径工具.basename(命令行脚本文件之文件名, 该命令行脚本文件之扩展名)
                }-吴乐川备份于-${时间戳}${
                    该命令行脚本文件之扩展名
                }`

                const 备份文件之完整路径 = 拼接路径片段(
                    容纳发布的文件的文件夹之完整路径,
                    备份文件之文件名
                )

                文件系统工具之扩展版.copySync(拟发布成为之文件之完整路径, 备份文件之完整路径)
                console.warn(`   ${粉笔工具.bgGreen.black(' 旧文件现已备份 ')} 。`)
            }



            const 原始范文的内容须先修订再发布 = true // 用于研发阶段的命令行工具集_这一文件夹之相对路径 !== 用于研发阶段的命令行工具集_这一文件夹之相对路径_默认值

            if (!原始范文的内容须先修订再发布) {
                文件系统工具之扩展版.copySync(原始范本文件之完整路径, 拟发布成为之文件之完整路径)
                console.log(`   ${粉笔工具.bgBlueBright.black(' 该文件现已发布 ')} 。\n\n`)
            } else {
                const 原始范本文件之内容全文 = 文件系统工具之扩展版.readFileSync(原始范本文件之完整路径).toString()

                let 原始范本文件之内容全文之逐行内容列表 = 原始范本文件之内容全文.split(/\n/)



                /**
                 * @typedef {object} 范_向范文内容中插入各依赖包相关信息时的简易配置列表
                 *
                 * @property {'产品级' | '研发级'}                    待处理的依赖包之种类
                 * @property {string}                                 在范文中引导插入或替换内容的标记文字
                 * @property {null | '版本无限制的' | '版本有限制的'} 仅应处理版本配置符合该标准的条目
                 */

                /** @type {Array<范_向范文内容中插入各依赖包相关信息时的简易配置列表>} */
                let 向范文内容中插入各依赖包相关信息时的简易配置列表 = []

                if (该命令行脚本文件确系PowerShell) {
                    向范文内容中插入各依赖包相关信息时的简易配置列表 = [
                        {
                            待处理的依赖包之种类: '产品级',
                            在范文中引导插入或替换内容的标记文字: 在_PowerShell_命令行范本中需替换为当前_npm_的_产品级_依赖包列表的占位文本,
                            仅应处理版本配置符合该标准的条目: null,
                        },
                        {
                            待处理的依赖包之种类: '研发级',
                            在范文中引导插入或替换内容的标记文字: 在_PowerShell_命令行范本中需替换为当前_npm_的_研发级_依赖包列表的占位文本,
                            仅应处理版本配置符合该标准的条目: null,
                        },
                    ]
                } else {
                    向范文内容中插入各依赖包相关信息时的简易配置列表 = [
                        {
                            待处理的依赖包之种类: '产品级',
                            在范文中引导插入或替换内容的标记文字: 在_Bash_命令行范本中需替换为当前_npm_的_产品级_依赖包列表的占位文本_凡可自由采用其版本者,
                            仅应处理版本配置符合该标准的条目: '版本无限制的',
                        },
                        {
                            待处理的依赖包之种类: '产品级',
                            在范文中引导插入或替换内容的标记文字: 在_Bash_命令行范本中需替换为当前_npm_的_产品级_依赖包列表的占位文本_凡须锁定其版本范围者,
                            仅应处理版本配置符合该标准的条目: '版本有限制的',
                        },
                        {
                            待处理的依赖包之种类: '研发级',
                            在范文中引导插入或替换内容的标记文字: 在_Bash_命令行范本中需替换为当前_npm_的_研发级_依赖包列表的占位文本_凡可自由采取其版本者,
                            仅应处理版本配置符合该标准的条目: '版本无限制的',
                        },
                        {
                            待处理的依赖包之种类: '研发级',
                            在范文中引导插入或替换内容的标记文字: 在_Bash_命令行范本中需替换为当前_npm_的_研发级_依赖包列表的占位文本_凡须锁定其版本范围者,
                            仅应处理版本配置符合该标准的条目: '版本有限制的',
                        },
                    ]
                }



                // 应开启调试功能 && console.debug('-'.repeat(64))
                // 应开启调试功能 && console.debug('原始范本文件之内容全文之逐行内容列表', 原始范本文件之内容全文之逐行内容列表)
                // 应开启调试功能 && console.debug('-'.repeat(64))
                // 应开启调试功能 && console.debug('向范文内容中插入各依赖包相关信息时的简易配置列表', 向范文内容中插入各依赖包相关信息时的简易配置列表)
                // 应开启调试功能 && console.debug('-'.repeat(64))



                向范文内容中插入各依赖包相关信息时的简易配置列表.forEach(({
                    待处理的依赖包之种类,
                    在范文中引导插入或替换内容的标记文字,
                    仅应处理版本配置符合该标准的条目,
                }) => {
                    原始范本文件之内容全文之逐行内容列表 = 查找范文中的某标记并将真实的依赖包版本配置插入其后({
                        应开启调试功能,

                        粉笔工具,

                        本工具集一切命令行消息之前缀,
                        本工具集自身的_packageJSON,

                        原始范本文件之内容全文之逐行内容列表,
                        在范文中引导插入或替换内容的标记文字,
                        产出的内容确系用于PowerShell代码: 该命令行脚本文件确系PowerShell,

                        其依赖包配置待处理的_packageJSON: 视作须为其安装本工具集的_npm_项目的_packageJSON,
                        待处理的依赖包之种类,
                        仅应处理版本配置符合该标准的条目,
                    })
                })

                let 修订后的范文内容全文 = 原始范本文件之内容全文之逐行内容列表.join('\n')



                修订后的范文内容全文 = 之于某命令行脚本文件之内容全文_修订其中提及的_用于研发阶段的命令行工具集({
                    文件内容修订前之全文: 修订后的范文内容全文,
                    该命令行脚本文件确系PowerShell,
                    用于研发阶段的命令行工具集_这一文件夹之相对路径_采纳值: 用于研发阶段的命令行工具集_这一文件夹之相对路径,
                    用于研发阶段的命令行工具集_这一文件夹之相对路径_默认值,
                })

                文件系统工具之扩展版.writeFileSync(拟发布成为之文件之完整路径, 修订后的范文内容全文)
                console[欲发布的文件业已存在 ? 'warn' : 'log'](`   ${粉笔工具.bgBlueBright.black(' 该文件现已发布 ')} 。\n\n`)
            }






        } else { // 这是 if (确应发布该文件) 配对的 else 。

            if (!欲发布的文件业已存在) {
                return
            }





            console.info(`${
                本工具集一切命令行消息之前缀
            }\n\n    找到${粉笔工具.yellow('旧有的')}命令行脚本：\n    "${
                粉笔工具.green(`${容纳发布的文件的文件夹之完整路径}${路径工具.sep}`)
            }${
                粉笔工具.greenBright(命令行脚本文件之文件名)
            }"\n`)



            const 命令行脚本文件之原始内容全文 = 文件系统工具之扩展版.readFileSync(拟发布成为之文件之完整路径).toString()



            const 该文件值得修订 = true // 横竖是要修订“用于研发阶段的命令行工具集” 这一配置的。再做如此检查则太麻烦。



            let 修订好的命令行脚本文件内容全文  = 之于某命令行脚本文件之内容全文_修订其中提及的_用于研发阶段的命令行工具集({
                文件内容修订前之全文: 命令行脚本文件之原始内容全文,
                该命令行脚本文件确系PowerShell,
                用于研发阶段的命令行工具集_这一文件夹之相对路径_采纳值: 用于研发阶段的命令行工具集_这一文件夹之相对路径,
                用于研发阶段的命令行工具集_这一文件夹之相对路径_默认值,
            })



            if (该命令行脚本文件确系PowerShell) {
                const 正则表达式1 = /\\@wulechuan\\cli-scripts--npm-project-helpers\\源代码\\PowerShell/

                // 该文件值得修订 = 正则表达式1.test(修订好的命令行脚本文件内容全文) // 横竖是要另外修订“用于研发阶段的命令行工具集” 这一配置的。

                修订好的命令行脚本文件内容全文 = 修订好的命令行脚本文件内容全文.replace(
                    正则表达式1,
                    '\\@wulechuan\\cli-scripts--npm-project-helpers\\源代码\\发布的源代码\\PowerShell'
                )
            } else {
                const 正则表达式1 = /\/@wulechuan\/cli-scripts--npm-project-helpers\/源代码\/bash/

                // 该文件值得修订 = 正则表达式1.test(修订好的命令行脚本文件内容全文) // 横竖是要另外修订“用于研发阶段的命令行工具集” 这一配置的。

                修订好的命令行脚本文件内容全文 = 修订好的命令行脚本文件内容全文.replace(
                    正则表达式1,
                    '/@wulechuan/cli-scripts--npm-project-helpers/源代码/发布的源代码/bash'
                )
            }



            if (该文件值得修订 && 修订好的命令行脚本文件内容全文) {
                文件系统工具之扩展版.writeFileSync(拟发布成为之文件之完整路径, 修订好的命令行脚本文件内容全文)



                console.info(`   ${粉笔工具.bgBlueBright.black(' 该旧有文件现已修订 ')} 。\n\n`)
            }
        }
    }




    /**
     * @param {object}  配置项集
     * @param {string}  配置项集.文件内容修订前之全文
     * @param {string}  配置项集.用于研发阶段的命令行工具集_这一文件夹之相对路径
     * @param {string}  配置项集.用于研发阶段的命令行工具集_这一文件夹之相对路径_默认值
     * @param {boolean} 配置项集.该命令行脚本文件确系PowerShell
     *
     * @returns {string}
     */
    function 之于某命令行脚本文件之内容全文_修订其中提及的_用于研发阶段的命令行工具集 ({
        文件内容修订前之全文,
        该命令行脚本文件确系PowerShell,
        用于研发阶段的命令行工具集_这一文件夹之相对路径_采纳值,
        用于研发阶段的命令行工具集_这一文件夹之相对路径_默认值,
    } = {}) {

        const 用于研发阶段的命令行工具集_这一文件夹之相对路径各级有效片段之列表 = 用于研发阶段的命令行工具集_这一文件夹之相对路径_采纳值.split(/[\\/]/).filter(片段 => !!片段)
        const 用于研发阶段的命令行工具集_这一文件夹之相对路径包含的路径层级数 = 用于研发阶段的命令行工具集_这一文件夹之相对路径各级有效片段之列表.length

        /**
         * 目前的真实情况是， “用于研发阶段的命令行工具集” 这一路径仅仅用于 PowerShell 脚本中的 -match 运算符后的【正则表达式】这一处。别无他处采用之。
         * 这时，即便文件是 PowerShell ，该正则表达式中的路径分隔符也必须为“双【反斜杠】”，而不是 PowerShell 风格的【代字符】 "`\" 。
         * 因此，暂时不必分过多情况讨论“应写入文件的各色路径中应采用的分隔符”的值。
         */
        let 写入文件的各色路径中应采用的分隔符 = 路径工具.sep === '\\' ? '\\\\' : 路径工具.sep
        if (!该命令行脚本文件确系PowerShell) {
            写入文件的各色路径中应采用的分隔符 = '/'
        }

        // /** @type {string} */
        // let 写入文件的各色路径中应采用的分隔符
        // if (该命令行脚本文件确系PowerShell) {
        //     写入文件的各色路径中应采用的分隔符 = 路径工具.sep === '\\' ? '`\\' : 路径工具.sep
        // } else {
        //     写入文件的各色路径中应采用的分隔符 = 路径工具.sep === '\\' ? '\\\\' : '/'
        // }



        let 修订后的内容全文 = 文件内容修订前之全文.replace(
            new RegExp(
                用于研发阶段的命令行工具集_这一文件夹之相对路径_默认值
                    .replace(/[[\]]/g, '\\$1')           // 先处理路径片段中原有的方括号。
                    .replace(/[\\/]/g, '[\\\\/]')        // 在处理路径分隔符（即 \ 或 /），此时要添加额外的方括号。
                    .replace(/([{(.$!^+\-)}])/g, '\\$1') // 最后处理其他对于文件路径而言可以使用但对正则表达式而言很特殊的字符。
                ,

                'g'
            ),

            用于研发阶段的命令行工具集_这一文件夹之相对路径各级有效片段之列表.join(写入文件的各色路径中应采用的分隔符)
        )



        if (该命令行脚本文件确系PowerShell) {
            const 须替换成的文本片段 = `Set-Location '${
                new Array(用于研发阶段的命令行工具集_这一文件夹之相对路径包含的路径层级数 + 1).fill('..').join('\\')
            }${'\\'}' # 确保进程的当前路径为接受本工具集服务的 npm 包的根文件夹。`

            console.debug(
                /[Ss][Ee][Tt]-[Ll][Oo][Cc][Aa][Tt][Ii][Oo][Nn]\s+'\.\.\\\.\.\\'\s+#\s*确保进程的当前路径为接受本工具集服务的 npm 包的根文件夹。/.test(修订后的内容全文),
                须替换成的文本片段
            )

            修订后的内容全文 = 修订后的内容全文.replace(
                /[Ss][Ee][Tt]-[Ll][Oo][Cc][Aa][Tt][Ii][Oo][Nn]\s+'\.\.\\\.\.\\'\s+#\s*确保进程的当前路径为接受本工具集服务的 npm 包的根文件夹。/,
                须替换成的文本片段
            )
        }



        return 修订后的内容全文
    }




    /**
     *
     * @param {object}                                 配置项集
     *
     * @param {boolean}                                配置项集.应开启调试功能
     *
     * @param {范_粉笔工具}                            配置项集.粉笔工具
     *
     * @param {string}                                 配置项集.本工具集一切命令行消息之前缀
     * @param {范_本工具集自身的_packageJSON}          配置项集.本工具集自身的_packageJSON
     *
     * @param {string[]}                               配置项集.原始范本文件之内容全文之逐行内容列表
     * @param {string}                                 配置项集.在范文中引导插入或替换内容的标记文字
     * @param {boolean}                                配置项集.产出的内容确系用于PowerShell代码
     *
     * @param {范_通用的_packageJSON}                  配置项集.其依赖包配置待处理的_packageJSON
     * @param {'产品级' | '研发级'}                    配置项集.待处理的依赖包之种类
     * @param {null | '版本无限制的' | '版本有限制的'} 配置项集.仅应处理版本配置符合该标准的条目 - 该配置项目前仅在处理 bash 文件时起作用。
     *

     * @returns {string[]}
     */
    function 查找范文中的某标记并将真实的依赖包版本配置插入其后 ({
        应开启调试功能,

        粉笔工具,

        本工具集一切命令行消息之前缀,
        本工具集自身的_packageJSON,

        原始范本文件之内容全文之逐行内容列表,
        在范文中引导插入或替换内容的标记文字,
        产出的内容确系用于PowerShell代码,

        其依赖包配置待处理的_packageJSON,
        待处理的依赖包之种类,
        仅应处理版本配置符合该标准的条目, // 该配置项目前仅在处理 bash 文件时起作用。
    } = {}) {
        const 本函数之一切消息之前缀 = `\n${本工具集一切命令行消息之前缀}\n函数： ${
            粉笔工具.magentaBright('查找范文中的某标记并将真实的依赖包版本配置插入其后({ ... })')
        }\n`



        应开启调试功能 && console.debug(本函数之一切消息之前缀, `>>>> ${产出的内容确系用于PowerShell代码 ? 'PowerShell' : 'Bash' } - ${待处理的依赖包之种类} - ${仅应处理版本配置符合该标准的条目} <<<<\n`)



        if (!Array.isArray(原始范本文件之内容全文之逐行内容列表)) {
            应开启调试功能 && console.debug(`${
                本函数之一切消息之前缀
            }    参数“原始范本文件之内容全文之逐行内容列表”的值并不是列表（Array）。\n`)

            return []
        }




        if (!其依赖包配置待处理的_packageJSON || typeof 其依赖包配置待处理的_packageJSON !== 'object') {
            console.error(`${
                本函数之一切消息之前缀
            }    ${
                粉笔工具.red('其依赖包配置待处理的_packageJSON 无效。')
            }其为：`, 其依赖包配置待处理的_packageJSON, '\n')

            return 原始范本文件之内容全文之逐行内容列表
        }

        if (Array.isArray(其依赖包配置待处理的_packageJSON)) {
            应开启调试功能 && console.debug(`${
                本函数之一切消息之前缀
            }    package.json 的内容怎么可能是列表（Array）？\n`)

            return 原始范本文件之内容全文之逐行内容列表
        }


        /** @type {范_通用的_packageJSON['dependencies'] | 范_通用的_packageJSON['devDependencies']} */
        let packageJSON_中本次所需处理的依赖包的配置集 = null

        if (待处理的依赖包之种类 === '产品级') {
            packageJSON_中本次所需处理的依赖包的配置集 = 其依赖包配置待处理的_packageJSON['dependencies']
        } else if (待处理的依赖包之种类 === '研发级') {
            packageJSON_中本次所需处理的依赖包的配置集 = 其依赖包配置待处理的_packageJSON['devDependencies']
        }



        if (!packageJSON_中本次所需处理的依赖包的配置集 || typeof packageJSON_中本次所需处理的依赖包的配置集 !== 'object') {
            return 原始范本文件之内容全文之逐行内容列表
        }

        if (Array.isArray(packageJSON_中本次所需处理的依赖包的配置集)) {
            应开启调试功能 && console.debug(`${
                本函数之一切消息之前缀
            }    package.json 中的依赖包版本配置（除了 bundledDependencies 外）怎么可能是列表（Array）？\n`)

            return 原始范本文件之内容全文之逐行内容列表
        }



        if (typeof 在范文中引导插入或替换内容的标记文字 !== 'string' || !在范文中引导插入或替换内容的标记文字.trim()) {
            console.error(`${
                本函数之一切消息之前缀
            }    ${
                粉笔工具.red('在尝试自动搜集依赖包并写入命令行脚本文件时，')
            }\n    ${
                粉笔工具.red('给出的“作为引导内容插入或替换标记的文字”无效。')
            }\n    ${
                粉笔工具.red('给出的标记文字如下：')
            }\n        "${
                粉笔工具.yellow(在范文中引导插入或替换内容的标记文字)
            }"\n`)

            return 原始范本文件之内容全文之逐行内容列表
        }



        /** @type {number[]} */
        const 匹配到标记文字的行的编号之列表 = 原始范本文件之内容全文之逐行内容列表.reduce((_匹配到的行的编号之列表, 范文的某行, 该行的列表编号) => {
            const 该行与标记文字匹配 = 范文的某行.indexOf(在范文中引导插入或替换内容的标记文字) >= 0
            if (该行与标记文字匹配) {
                _匹配到的行的编号之列表.push(该行的列表编号)
            }

            return _匹配到的行的编号之列表
        }, [])

        if (匹配到标记文字的行的编号之列表.length < 1) {

            console.error(`${
                本函数之一切消息之前缀
            }\n    ${
                粉笔工具.red('在尝试自动搜集依赖包并写入命令行脚本文件时，')
            }\n    ${
                粉笔工具.red('在原始范文中没有找到“作为引导内容插入或替换标记的文字”。')
            }\n    ${
                粉笔工具.red('给出的标记文字如下：')
            }\n        "${
                粉笔工具.yellow(在范文中引导插入或替换内容的标记文字)
            }"`)

            return 原始范本文件之内容全文之逐行内容列表

        } else if (匹配到标记文字的行的编号之列表.length > 1) {

            console.error(`${
                本函数之一切消息之前缀
            }\n    ${
                粉笔工具.red('在尝试自动搜集依赖包并写入命令行脚本文件时，')
            }\n    ${
                粉笔工具.red(`在原始范文中寻找“作为引导内容插入或替换标记的文字”时，找到${
                    粉笔工具.yellow(`不止一处，共 ${匹配到标记文字的行的编号之列表.length} 处`)
                }。`)
            }\n    ${
                粉笔工具.red('给出的标记文字如下：')
            }\n        "${
                粉笔工具.yellow(在范文中引导插入或替换内容的标记文字)
            }"`)

            return 原始范本文件之内容全文之逐行内容列表

        }



        if (待处理的依赖包之种类 === '研发级') {
            const 本工具集自身之名称 = 本工具集自身的_packageJSON.name
            const 本工具集自身之版本 = 本工具集自身的_packageJSON.version

            if (!(本工具集自身之名称 in packageJSON_中本次所需处理的依赖包的配置集)) {
                /**
                 * 在某 npm 项目（暂称甲）中安装本工具集刚完成时，
                 * npm 就会运行本工具的安装脚本。
                 * 此时，甲的 package.json 中往往还未提及本工具集。
                 */
                packageJSON_中本次所需处理的依赖包的配置集[本工具集自身之名称] = `^${本工具集自身之版本}`
            }
        }



        const 唯一匹配到的标记文字所在行的列表编号 = 匹配到标记文字的行的编号之列表[0]

        /** @type {string} */
        const 唯一匹配到的标记文字所在行的内容全文 = 原始范本文件之内容全文之逐行内容列表[唯一匹配到的标记文字所在行的列表编号]
        const 唯一匹配到的标记文字所在行起始的空白的匹配结果 = 唯一匹配到的标记文字所在行的内容全文.match(/^\s*/)

        let 唯一匹配到的标记文字所在行起始的空白 = ''
        if (唯一匹配到的标记文字所在行起始的空白的匹配结果) {
            唯一匹配到的标记文字所在行起始的空白 = 唯一匹配到的标记文字所在行起始的空白的匹配结果[0]
        }
        // console.debug(`>>>>> 唯一匹配到的标记文字所在行起始的空白 = '${唯一匹配到的标记文字所在行起始的空白}'`)



        const 拟写入命令行脚本文件的内容的简易配置列表 = Object.keys(packageJSON_中本次所需处理的依赖包的配置集).map(某产品级依赖包之名称 => {
            const 某产品级依赖包之版本配置 = packageJSON_中本次所需处理的依赖包的配置集[某产品级依赖包之名称]

            let 已知该版本已经锁定在某范围内 = false
            let 已知该依赖包不必安装 = false
            if (typeof 某产品级依赖包之版本配置 === 'string') {
                if (/^(file|git|git+ssh|git+http|git+https|http|https):/i.test(某产品级依赖包之版本配置)) {
                    已知该依赖包不必安装 = true
                } else if (/^=\d+/.test(某产品级依赖包之版本配置)) {
                    已知该版本已经锁定在某范围内 = true
                }
            }

            if (已知该版本已经锁定在某范围内) {
                return { 某产品级依赖包之名称, 已知该版本已经锁定在某范围内, 已知该依赖包不必安装, 某产品级依赖包之版本配置 }
            } else {
                return { 某产品级依赖包之名称, 已知该版本已经锁定在某范围内, 已知该依赖包不必安装, 某产品级依赖包之版本配置: 'latest' }
            }
        }).filter(依赖包版本简易配置 => !依赖包版本简易配置.已知该依赖包不必安装)



        /** @type {string[]} */
        let 须写入命令行脚本文件的内容的诸行之列表

        if (产出的内容确系用于PowerShell代码) {

            /** @type {number} */
            const 已知依赖包名称中最长者之字符数 = Math.max(
                ...拟写入命令行脚本文件的内容的简易配置列表.map(
                    ({ 某产品级依赖包之名称 }) => 某产品级依赖包之名称.length
                )
            )

            /** @type {string[]} */
            const 命令诸行 = 拟写入命令行脚本文件的内容的简易配置列表.map(({
                某产品级依赖包之名称,
                已知该版本已经锁定在某范围内,
                某产品级依赖包之版本配置,
            }) => {
                const 该依赖包之名称后须补足的空格数 = Math.max(0, 已知依赖包名称中最长者之字符数 - 某产品级依赖包之名称.length)

                if (已知该版本已经锁定在某范围内) {
                    return `'${某产品级依赖包之名称}'${' '.repeat(该依赖包之名称后须补足的空格数)} = @('${某产品级依赖包之版本配置}', '不妨在此填写该依赖包版本被锁定的原因。')`
                } else {
                    return `'${某产品级依赖包之名称}'${' '.repeat(该依赖包之名称后须补足的空格数)} = $null`
                }
            }).map(须写入命令行脚本文件的某行内容 => {
                return `${唯一匹配到的标记文字所在行起始的空白}${须写入命令行脚本文件的某行内容}`
            })



            须写入命令行脚本文件的内容的诸行之列表 = [
                '',
                ...命令诸行,
            ]

        } else {

            const 确实须写入命令行脚本文件的内容的简易配置列表 = 拟写入命令行脚本文件的内容的简易配置列表.filter(依赖包版本简易配置 => {
                return (
                    仅应处理版本配置符合该标准的条目 === '版本有限制的' && 依赖包版本简易配置.已知该版本已经锁定在某范围内
                ) || (
                    仅应处理版本配置符合该标准的条目 === '版本无限制的' && !依赖包版本简易配置.已知该版本已经锁定在某范围内
                )
            })

            /** @type {string[]} */
            let 注释诸行 = []

            /** @type {string[]} */
            let 命令诸行 = []

            const npm命令行参数集 = {
                '产品级': '',
                '研发级': '  -D',
            }[待处理的依赖包之种类]
            const npm命令行首部 = `npm  i${npm命令行参数集 || ''}`



            const 本种类的依赖包个数为零 = 确实须写入命令行脚本文件的内容的简易配置列表.length === 0

            if (本种类的依赖包个数为零) {

                if (仅应处理版本配置符合该标准的条目 === '版本有限制的') {
                    注释诸行 = [
                        `# ${'─'.repeat(27)}`,

                        '# 暂无。',
                    ]
                }

            } else {

                if (仅应处理版本配置符合该标准的条目 === '版本有限制的') {
                    注释诸行 = [
                        `# ${'─'.repeat(27)}`,

                        ...确实须写入命令行脚本文件的内容的简易配置列表.map(({
                            某产品级依赖包之名称,
                            某产品级依赖包之版本配置,
                        }, 简易配置之编号, 简易配置之完整列表) => {
                            return [
                                `# ${某产品级依赖包之名称}@${某产品级依赖包之版本配置}`,
                                '#     不妨说明该依赖包版本被锁定的原因。',
                                简易配置之编号 < 简易配置之完整列表.length - 1 ? '#' : null,
                            ]
                        }).reduce((展平的列表, 某片段的列表) => [ ...展平的列表, ...某片段的列表 ], []),
                    ].filter(内容 => 内容 !== null)
                }



                命令诸行 = [
                    `${npm命令行首部} \\`,

                    ...确实须写入命令行脚本文件的内容的简易配置列表.map(({
                        某产品级依赖包之名称,
                        某产品级依赖包之版本配置,
                    }) => {
                        return `${某产品级依赖包之名称}@${某产品级依赖包之版本配置}`
                    }).map((须写入命令行脚本文件的某行内容, 列表编号, 完整列表) => {
                        return `    ${须写入命令行脚本文件的某行内容}${
                            列表编号 < 完整列表.length - 1 ? ' \\' : ''
                        }`
                    }),
                ]

            } // 这是 if (本种类的依赖包个数为零) 的终点。



            须写入命令行脚本文件的内容的诸行之列表 = [
                '',
                `if ${本种类的依赖包个数为零 ? 'true' : 'false' }; then`,
                '',

                '    echo  \'暂无。\'',

                '',
                'else',
                '',

                '    if [ $ShouldDryRun -eq 1 ]; then',
                '        echo  -e  "   \\e[0;33m【仿真演练】\\e[0;0m"',
                '    fi',
                '',

                ...本种类的依赖包个数为零
                    ? [
                        `    # echo  '${npm命令行首部}  ????????@0.0.0'`,
                    ]
                    : (
                        命令诸行.map(未缩进的代码行或注释行 => {
                            if (!未缩进的代码行或注释行.trim()) {
                                return ''
                            }

                            return `    echo  '    ${未缩进的代码行或注释行}'`
                        })
                    )
                ,
                '',
                '    echo',
                `    echo  -en  "${待处理的依赖包之种类 === '产品级' ? '\\e[0;31m' : '\\e[0;32m'}"`,
                '    Write-Line-without-line-break',
                '    echo  -e   "\\e[0;0m"',
                '    echo',

                '',
                '    if [ $ShouldDryRun -eq 0 ]; then',
                '',

                ...[
                    ...注释诸行,

                    `# ${'─'.repeat(27)}`,

                    ...(本种类的依赖包个数为零
                        ? [
                            '',
                            '[ 0 ]',
                            '',
                        ]
                        : 命令诸行
                    ),

                    `# ${'─'.repeat(27)}`,
                ].map(未缩进的代码行或注释行 => {
                    if (!未缩进的代码行或注释行.trim()) {
                        return ''
                    }

                    return `        ${未缩进的代码行或注释行}`
                }),

                '',
                '    fi',
                '',
                'fi',
            ].map(尚未整体统一缩进的代码行或注释行 => {
                if (!尚未整体统一缩进的代码行或注释行.trim()) {
                    return ''
                }

                return `${
                    唯一匹配到的标记文字所在行起始的空白
                }${
                    尚未整体统一缩进的代码行或注释行
                }`
            })

        } // 这是 if (产出的内容确系用于PowerShell代码) 配对的 else 的终点。



        const 修订好的内容全文之诸行列表 = [
            ...原始范本文件之内容全文之逐行内容列表.slice(0, 唯一匹配到的标记文字所在行的列表编号 + 1),

            ...须写入命令行脚本文件的内容的诸行之列表,

            ...原始范本文件之内容全文之逐行内容列表.slice(唯一匹配到的标记文字所在行的列表编号 + 1),
        ]



        // 应开启调试功能 && console.debug(`${
        //     本函数之一切消息之前缀
        // }>>>>> 修订好的内容全文之诸行列表`, 修订好的内容全文之诸行列表)
        // 应开启调试功能 && console.debug('<<<<')



        return 修订好的内容全文之诸行列表
    }
}
